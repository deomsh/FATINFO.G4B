!BAT
#-#+ FATINFO.G4B v0.8.1 (20260124), by deomsh
#-#+ Function: get file-system info (FAT-devices/ image files only)
#-#+ Use 1 FATINFO.G4B [--mdbase=sector] [--hex] DEVICE switch
#-#+ Use 2 FATINFO.G4B [--mdbase=sector] [--start=sector|--skip=offset|--partition=n] [--hex] FILE switch
#-#+ Use 3 FATINFO.G4B [--mdbase=sector] [--start=sector|--skip=offset|--partition=n] [--hex] BLOCKLIST switch
#-#+ Use 4 FATINFO.G4B [--mdbase=sector] --start=sector|--skip=address [--hex] DISK switch
#-#+ Switches [/T|/TQ|/F|/FT|/A|/A32|/L|/L32|/B|/V] | /?
#-#+ Help FATINFO.G4B /?
#-# --mdbase=sector to change base sector of memory in use (default=0x3000 ; 0x200 sectors in use)
#-# --start=sector to set sector on imagefile to read-out bootsector(s) (default start=0)
#-# --skip=address to set address on imagefile to read-out bootsector(s) (default skip=0)
#-# Switches: /T for basis tests fat info; /TQ same but quiet (result=1 if all tests passed, 0 if not, or variable not exists no/ not all tests possible; /F returns result=1 if FAT; /FT returns result=fatxx; /A returns free space (result=n bytes); /A32 same, but returns count of free space on fat32; /L returns result=last allocated clusternumber; /L32 same, but count on fat32; /V returns variables FILESYS BYTEPSEC SECPCLUS RESERVED NUMFATS SECPFAT SECTRACK NUMHEADS ROOTENTR DEVSECT MEDIABYT UUID + on fat32: CLUSFREE NEXTFREE
#-# Tests: Media descriptor, Fit on partition, Last sector valid, Number of tracks/cylinders, Balanced CHS/LBA, Signatures, Number of sectors per fat, Media descriptor in FAT1, FAT1 and FAT2 are equal, FSInfo equal to count of free clusters (fat32 only), FSLastFree equal to last free cluster (fat32 only)
#-# Remarks: Source DEVICE must be given in parentheses. FILE must contain a path. One switch at the end only. Switches gives quiet operation, except /T . Supported grub4dos versionS: 20170607 or later
#-# Example 1:  FATINFO.G4B (fd0)
#-# Example 2:  FATINFO.G4B (hd0,0)
#-# Example 3:  FATINFO.G4B (fd0) /T
#-# Example 4:  FATINFO.G4B (hd1,0) /TQ ;; set result
#-# Example 5:  FATINFO.G4B (fd1) /F ;; set result
#-# Example 6:  FATINFO.G4B (fd1) /FQ ;; set result
#-# Example 7:  FATINFO.G4B (rd)
#-# Example 8:  FATINFO.G4B (fd1) /V ;; set
#-# Example 9:  FATINFO.G4B (hd1,0)/FDDIMAGE.IMG
#-# Example 10: FATINFO.G4B --start=63 /HDDIMAGE.IMG /T
#-# Example 11: FATINFO.G4B --skip=0x85E00 /HDDIMAGE.IMG /T
#-# Example 12: FATINFO.G4B  (0xe0)0x2C+720
#-# Example 13: FATINFO.G4B --partition=0 (hd0,0)44992028+2g
#-# Example 14: FATINFO.G4B --start=1929 (cd)
::--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
:: MAIN ROUTINE
::--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if "%~1"=="" && call :smallhelp smallhelp && goto :eof
if "%~1"=="/?" && call :help && goto :eof
if not exist @uefi &; setlocal && set /a version=*0x8278&0xFFFFFFFF > nul &; if %version%>=20170505 && endlocal ! echo Grub4dos version %version% too old, use version 20170505 or later && endlocal && goto :eof
#BADforGrub4EFI*setlocal && set /a version=*0x8278 > nul &; if %version%>=20170607 && endlocal ! echo Grub4dos version %version% too old, use version 20170607 or later && endlocal && goto :eof
#steve6375#checkrange 20170607:-1 read 0x8278 || pause --wait=3 Please use grub4dos-0.4.6a-2017-06-07 or later! && goto :eof
setlocal && set *
set result=1
debug status > nul ;; set debugsts=%@retval%
debug 1
debug msg=0
set "rootorg=%@root%" &; if not exist @uefi && if "%rootorg:~0,3%"=="(cd" && set /A drvnum=*0x82A0&0xff > nul &; if "%rootorg:~3,1%"==")" && set "rootorg=(%drvnum%)%rootorg:~4%" ! set "rootorg=(%drvnum%)%rootorg:~5%"
:switchloop
if not exist startsec && if not exist skipbyte &; if /i "%~1"=="--start" && set /a startsec=%~2 && shift && shift && goto :switchloop
if not exist startsec && if not exist skipbyte &; if /i "%~1"=="--skip" && set /a skipbyte=%~2 && shift && shift && goto :switchloop
if not exist mdbase &; if /i "%~1"=="--mdbase" && set /A mdbase=%~2 && shift && shift && goto :switchloop
if not exist partitio &; if /i "%~1"=="--partition" && set /a partitio=%~2 && shift && shift && goto :switchloop
if not exist hexview &; if /i "%~1"=="--hex" && set hexview=Y && shift && goto :switchloop
if exist partitio &; if not %partitio%>=0 && echo Wrong partition number '%partitio%'%NULL% && set result=0 && set hexview=N && goto :endlocal ! if %partitio%>=63 && echo Partition number '%partitio%' out of range%NULL% && set result=0 && set hexview=N && goto :endlocal
if not /i %~2==/T if not /i %~3==/T || set test=Y
if not /i %~2==/TQ if not /i %~3==/TQ || set test=Y && set "NULL= > nul"
if not /i %~2==/F if not /i %~3==/F || set isFAT=Y && set "NULL= > nul"
if not /i %~2==/FT if not /i %~3==/FT || set isFATxx=Y && set "NULL= > nul"
if not /i %~2==/A if not /i %~3==/A || set getfreeB=Y && set "NULL= > nul"
if not /i %~2==/A32 if not /i %~3==/A32 || set getfree3=Y && set "NULL= > nul"
if not /i %~2==/L if not /i %~3==/L || set getnext=Y && set "NULL= > nul"
if not /i %~2==/L32 if not /i %~3==/L32 || set getnext3=Y && set "NULL= > nul"
if not /i %~2==/V if not /i %~3==/V || set getvars=Y && set "NULL= > nul"
if not /i %~2==/B if not /i %~3==/B || set getbadcl=Y && set "NULL= > nul"
if not /i %~2==/BC if not /i %~3==/BC || set getbootc=Y && set "NULL= > nul"
if %hexview%==Y &; pager status > nul && set pagersts=1 ! set pagersts=0 &; pager on
set ARG=%~1
if %ARG:~0,1%==( && if %ARG:~-1,1%==) && set device=%~d1 &; if not exist startsec if not exist skipbyte if not exist partitio || set disk=Y
set ARG=
if not exist device &; call Fn.11 "%~1" "/" && if not "%~n1"=="" && set "FILE=%~f1" && set "PATH=%~p1" && set "NAME=%~n1" && set "EXT=%~x1" && set disk=
if not exist device && if not exist FILE &; call Fn.11 "%~1" "+" &; if "%~x1"=="" && set "FILE=%~1" && set block=Y && set disk= ! echo '%~1' is not a valid blocklist%NULL% && set result=0 && set hexview=N && goto :endlocal
if not exist device && if not exist FILE &; echo No DEVICE/ FILE/ BLOCKLIST or DISK on command-line%NULL% && set result=0 && set hexview=N && goto :endlocal
if exist device &; raw cat --hex --length=1 %device%%0+1 > nul || echo %device% does not exist%NULL% && set result=0 && set hexview=N && goto :endlocal
if exist FILE && if %block%==Y &; call Fn.11 "%FILE:~0,1%" "(" call Fn.11 "%FILE:~1,8%" ")" || echo %FILE% is not a valid blocklist%NULL% && set result=0 && set hexview=N && goto :endlocal
if not "%~2"=="" && if not exist test && if not exist isFAT && if not exist isFATxx && if not exist getfreeB && if not exist getfree3 && if not exist getnext && if not exist getnext3 && if not exist getbootc && if not exist getvars &; echo Argument '%~2' on command-line is not valid%NULL% && set result=0 && set hexview=N && goto :endlocal
if not %disk%==Y if not %block%==Y || set DISK=%~d1
if exist DISK &; if %DISK:~0,3%==(cd && set CDROM=Y ! if not %DISK:~0,3%==(fd && if not %DISK:~0,3%==(hd && if not %DISK:~0,3%==(md && if not %DISK:~0,3%==(rd && if not %DISK:~1,-1%<=0x9E && if %DISK:~1,-1%>=0x9F && set CDROM=Y ! set CDROM= &; if %CDROM%==Y && if exist skipbyte && set /a startsec=%skipbyte%>>9 && set /a CDstart=%skipbyte%>>11 && set DISK= ! if %CDROM%==Y && if not exist skipbyte && set CDstart=%startsec% && set /a startsec=%startsec% * 4 && set DISK= ! set DISK= && if exist skipbyte && set /a startsec=%skipbyte%>>9 && set skipbyte= &; if %CDROM%==Y && if exist skipbyte && setlocal && set /A startbyt=%CDstart% * 2k &; endlocal && set /A offset=%skipbyte%-%startbyt% && set skipbyte=
if /i "%EXT%"==".iso" &; if exist startsec && set /a startsec=%startsec% * 4
if exist FILE &; if exist skipbyte && set /a startsec=%skipbyte%>>9 && set skipbyte=
#ProcessingFILEandBLOCKLIST#
if exist FILE && if not %disk%==Y &; if not %FILE:~0,3%==(rd &; call Fn.11 "%FILE%" "\ " && echo -e "%file%" | set file= &; set "file=%file:~1,-1%" &; setlocal && call :lsspaces "%FILE%" "\x20" &; echo -n > (md)0x300+1 && endlocal && set "FILE=%file%"
if exist FILE && if not %disk%==Y &; if not %FILE:~0,3%==(rd &; call Fn.11 "%FILE%" "=" && setlocal && call :lsspaces "%FILE%" "\x3D" &; echo -n > (md)0x300+1 && endlocal && set "FILE=%file%"
if exist FILE && if not %disk%==Y &; if not %FILE:~0,3%==(rd &; raw cat --length=0 %FILE% > nul && set /A filesize=*0x8290 ! echo %FILE% does not exist%NULL% && set result=0 && set hexview=N && goto :endlocal
if exist FILE && if not %disk%==Y &; if %FILE:~0,3%==(rd && if not exist @uefi &; raw cat --length=0 %FILE% > nul && set /A filesize=*0x8290 ! echo %FILE% does not exist%NULL% && set result=0 && set hexview=N && goto :endlocal
#CheckFilesizeOf(rd)-BlocklistOnGrub4efi#
if exist FILE && if not %disk%==Y &; if %FILE:~0,3%==(rd && if exist @uefi && if %block%==Y &; raw cat --length=0 %FILE% > nul && set /A filesize=*0x8290 ! echo %FILE% does not exist%NULL% && set result=0 && set hexview=N && goto :endlocal
if exist FILE && if not %disk%==Y &; if %FILE:~0,3%==(rd && if exist @uefi && if not %block%==Y &; set /A filesize=*0x82D8 &; if %filesize%==0 && echo %FILE% does not exist%NULL% && set result=0 && set hexview=N && goto :endlocal ! cat --hex --length=1 %FILE% > nul || echo Blocklist %FILE% does not exist%NULL% && set result=0 && set hexview=N && goto :endlocal ! cat --hex --skip=%filesize% --length=1 %FILE% > nul || echo %FILE% with filesize %filesize% does not exist%NULL% && set result=0 && set hexview=N && goto :endlocal
if exist FILE && if %block%==Y && if not exist partitio && set RD=%FILE% &; cat --length=0 %FILE% > nul && if %CDROM%==Y && set /a sectors=*0x8290>>11 ! set /a sectors=*0x8298>>9 ! set sectors=0
if exist FILE && if %block%==Y && if not exist partitio && call Fn.11 "%FILE:~6%" "," && set RD=%FILE% && setlocal &; call Fn.11 "%FILE%" "(" &; set /a pos0=%@retval% &; call Fn.11 "%FILE%" ")" &; set /a pos1=%@retval% &; call Fn.11 "%FILE%" "+" &; set /a pos2=%@retval% &; set /a S=%pos1%-%pos0%+1 && set /a L=%pos2%-%pos1%-1 &; call set /a start=%^FILE:~%S%,%L%%% &; endlocal && set start=%start%
if exist FILE && if %block%==Y && if not exist partitio &; call Fn.11 "%FILE:~6%" "," |; set RD=%FILE% && setlocal &; call Fn.11 "%FILE%" "(" &; set /a pos0=%@retval% &; call Fn.11 "%FILE%" ")" &; set /a pos1=%@retval% &; call Fn.11 "%FILE%" "+" &; set /a pos2=%@retval% &; set /a S=%pos1%-%pos0%+1 && set /a L=%pos2%-%pos1%-1 &; call set /a start=%^FILE:~%S%,%L%%% &; endlocal && set start=%start%
#BAD:'if .. && if .. && ' before 'call Fn.11 |; '#if exist FILE && if %block%==Y && if not exist partitio && call Fn.11 "%FILE:~6%" "," |; set RD=%FILE% && setlocal &; call Fn.11 "%FILE%" "(" &; set /a pos0=%@retval% &; call Fn.11 "%FILE%" ")" &; set /a pos1=%@retval% &; call Fn.11 "%FILE%" "+" &; set /a pos2=%@retval% &; set /a S=%pos1%-%pos0%+1 && set /a L=%pos2%-%pos1%-1 &; call set /a start=%^FILE:~%S%,%L%%% &; endlocal && set start=%start%
if exist FILE && if not exist %FILE% && echo %FILE% does not exist%NULL% && set result=0 && set hexview=N && goto :endlocal
#ProcessingDISK#
if %disk%==Y && if exist partitio && call Fn.11 "%device%" "," &; echo Partitioned device %device% not supported with '--partition=n'%NULL% && set result=0 && set hexview=N && goto :endlocal
if %disk%==Y && if exist partitio &; if not exist start if not exist startsec if not exist skipbyte if not exist offset || echo Partitioned device %device% not supported with '--start=sector|--skip=offset'%NULL% && set result=0 && set hexview=N && goto :endlocal
#BAD#if %disk%==Y && Fn.11 "%device%" "," if exist partitio &; echo Partitioned device %device% not supported with '--start=sector|--skip=offset'%NULL% && goto :endlocal
if %disk%==Y && if %CDROM%==Y && if not exist @uefi && setlocal && set /A diffsec=300m>>11 &; set CDtotsec=%diffsec% && set diff2sec=%diffsec% && call :getCDtotsec &; if not exist CDtotsec && echo Can not find total sectors on CD/DVD%NULL% && endlocal && set result=0 && set hexview=N && goto :endlocal ! endlocal && set CDtotsec=%CDtotsec% && set filesize=%CDtotsec% * 2k
if %disk%==Y && if %CDROM%==Y && if exist @uefi &; raw cat --length=0 %device% > nul && set /a CDtotsec=*0x8290>>7 && set /A filesize=*0x8290 ! Can not find total sectors on CD/DVD && set result=0 && set hexview=N && goto :endlocal
#NO RD used if NO (rd)#
if %disk%==Y && if not %device:~0,3%==(rd && if not %CDROM%==Y && setlocal &; rootnoverify %device% && set /A devstart=*0x82A8&0xffffffff && set /a devsect=*0x82B0&0xfffffffff && root %rootorg% > nul &; if %devstart%==0 && set /a sectors=%devsect%-%startsec% &; endlocal && set FILE=%device%%0+%devsect% && set disk=Y && set device= && set /a filesize=%devsect%<<9
#BAD#if %disk%==Y && if not %device:~0,3%==(rd && if not %CDROM%==Y && setlocal &; rootnoverify %device% && set /A devstart=*0x82A8&0xffffffff && set /a devsect=*0x82B0&0xfffffffff && root %rootorg% > nul &; if %devstart%==0 && set /a sectors=%devsect%-%startsec% &; endlocal && set FILE=%device%%0+%devsect% && set disk=Y && set device=
if exist partitio && if %device%==(rd) && setlocal &; set /A devstart=*0x82D0&0xffffffff && set /a devsect=*0x82D8&0xffffffff>>9 &; if %devstart%>=1m && if %devsect%>=8 && endlocal && set /a sectors=%devsect% && set FILE=%device%%0+%devsect% && set disk=Y && set RD=%device%%0 && set device= && set /a filesize=*0x82D8&0xffffffff && set disk= ! set result=0 && set hexview=N && goto :endlocal
if exist partitio && if exist FILE && call :findstartsector &; if %result%==0 && echo Abort: start-sector of partition %partitio% not found%NULL% && set result=0 && set hexview=N && goto :endlocal ! set /a startsec=%result% && set result=1
if %disk%==Y && if %device:~0,4%==(rd) && setlocal &; set /A devstart=*0x82D0 && set /a devsect=*0x82D8&0xfffffffff>>9 &; if %devstart%>=1m && if %devsect%>=8 && set /a sectors=%devsect%-%startsec% &; endlocal && set FILE=%device%%0+%devsect% && set disk=Y && set RD=%device%%%startsec% && set sectors=%sectors% && set device= && set /a filesize=%devsect%<<9
#BAD##if %disk%==Y && if %device:~0,4%==(rd) && setlocal &; set /A devstart=*0x82D0 && set /a devsect=*0x82D8&0xfffffffff>>9 &; if %devstart%>=1m && if %devsect%>=8 && set /a sectors=%devsect%-%startsec% &; endlocal && set FILE=%device%%0+%devsect% && set disk=Y && set RD=%device%%%startsec% && set sectors=%sectors% && set device=
if %disk%==Y && if %CDROM%==Y && setlocal &; set /a sectors=%CDtotsec%-%CDstart% &; endlocal && set FILE=%device%%0+%CDtotsec% && set disk=Y && set RD=%device%%%CDstart% && set sectors=%sectors% && set device= && set /a filesize=%CDtotsec%<<11
#BAD?#if %disk%==Y && if %CDROM%==Y && setlocal &; set /a sectors=%CDtotsec%-%CDstart% &; endlocal && set FILE=%device%%0+%CDtotsec% && set disk=Y && set RD=%device%%%CDstart% && set sectors=%sectors% && set device=
#Integration:BothTreatedAsBlocklist#
if %block%==Y && set disk=Y &; if exist start && set devstart=%start%
#ORG#if %block%==Y && set disk=Y
if not exist startsec && set startsec=0
if exist start && set start=0
if %CDROM%==Y && if not exist CDstart && set CDstart=0
if not exist offset && set offset=0 ! if %CDROM%==Y && if not %offset%==0 && set /A OFFSET=%CDstart% * 2k + %offset%
if not exist mdbase && set mdbase=0x3000
if not exist FILE && call :bootblockbase "device" &; if %result%==0 && if not %test%==Y && echo No FAT info possible on %device%%%NULL% && set result=0 && set hexview=N && goto :endlocal ! if %result%==0 && echo No FAT filesystem found on %device%%%NULL% && set result= && set hexview=N && goto :endlocal ! set result=1
#DEBUG#pause offset=%offset% OFFSET=%OFFSET% startsec=%startsec%
if exist FILE && call :bootblockbase "FILE" &; if %result%==0 && if %CDROM%==Y && if exist OFFSET && echo No FAT info possible on %FILE% starting at offset %OFFSET%%%NULL% && set hexview=N && goto :endlocal ! if %result%==0 && if %CDROM%==Y && echo No FAT info possible on %FILE% starting at sector %CDstart%%%NULL% && set hexview=N && goto :endlocal ! if %result%==0 && echo No FAT info possible on %FILE% starting at sector %startsec%%%NULL% && set hexview=N && goto :endlocal ! if not /i %filesys:~0,3%==fat && if %CDROM%==Y && if exist OFFSET && echo No FAT filesystem found on %FILE% starting at offset %OFFSET%%%NULL% && set result=0 && set hexview=N && goto :endlocal ! if not /i %filesys:~0,3%==fat && if %CDROM%==Y && echo No FAT filesystem found on %FILE% starting at sector %CDstart%%%NULL% && set result=0 && set hexview=N && goto :endlocal ! if not /i %filesys:~0,3%==fat && echo No FAT filesystem found on %FILE% starting at sector %startsec%%%NULL% && set hexview=N && goto :endlocal ! if %test%==Y && set result=1
#BAD#if exist FILE && call :bootblockbase "FILE" &; if %result%==0 && if %CDROM%==Y && if exist OFFSET && echo No FAT info possible on %FILE% starting at offset %OFFSET%%%NULL% && set hexview=N && goto :endlocal ! if %result%==0 && if %CDROM%==Y && echo No FAT info possible on %FILE% starting at sector %CDstart%%%NULL% && set hexview=N && goto :endlocal ! if %result%==0 && echo No FAT info possible on %FILE% starting at sector %startsec%%%NULL% && set hexview=N && goto :endlocal ! if not /i %filesys:~0,3%==fat && if %CDROM%==Y && if exist OFFSET && echo No FAT filesystem found on %FILE% starting at offset %OFFSET%%%NULL% && set result=0 && set hexview=N && goto :endlocal ! if not /i %filesys:~0,3%==fat && if %CDROM%==Y && echo No FAT filesystem found on %FILE% starting at sector %CDstart%%%NULL% && set result=0 && set hexview=N && goto :endlocal ! if not /i %filesys:~0,3%==fat && echo No FAT filesystem found on %FILE% starting at sector %startsec%%%NULL% && set hexview=N && goto :endlocal ! if %test%==Y && set result=1 && set OFFSET= ! set OFFSET=
if %isFATxx%==Y &; if /i %filesys:~0,3%==fat && set result=%filesys% ! set result=0 && set hexview=N &; goto :endlocal
if %isFAT%==Y &; if /i %filesys:~0,3%==fat && set result=1 ! set result=0 && set hexview=N &; goto :endlocal
## Extra check of filesys?
if not exist FILE && call :checkfatsubtype "%numclus%" &; if not exist filesys && echo No FAT info possible on %device%%%NULL% && set result=0 && set hexview=N && goto :endlocal ! if not %filesys%==%filesysT% && echo Sub-routine 'bootblockbase' returned wrong FAT type: %filesys%%%NULL% && set %filesys%=%filesysT% && set filesysT= ! set filesysT=
if exist FILE && call :checkfatsubtype "%numclus%" &; if not exist filesys && if exist OFFSET && echo No FAT info possible on %FILE% at offset %OFFSET%%%NULL% && set result=0 && set hexview=N && goto :endlocal ! if not exist filesys && if %startsec%>=1 && echo No FAT info possible on %FILE% at sector %startsec%%%NULL% && set result=0 && set hexview=N && goto :endlocal ! if not exist filesys && echo No FAT info possible on %FILE%%%NULL% && set result=0 && set hexview=N && goto :endlocal ! if not %filesys%==%filesysT% && echo Sub-routine 'bootblockbase' returned wrong FAT type: %filesys%%%NULL% && set %filesys%=%filesysT% && set filesysT= ! set filesysT=
#BAD#if exist FILE && call :checkfatsubtype "%numclus%" &; if not exist filesys && echo No FAT info possible on %FILE%%%NULL% && set result=0 && set hexview=N && goto :endlocal ! if not %filesys%==%filesysT% && echo Sub-routine 'bootblockbase' returned wrong FAT type: %filesys%%%NULL% && set %filesys%=%filesysT% && set filesysT= ! set filesysT=
#WATCH: if setlocal in sub-routine :getfreeclustersfat32 is passed, endlocal not active#
if %getfree3%==Y && if not /i %filesys%==fat32 && set result= && set hexview=N && goto :endlocal
if %getnext3%==Y && if not /i %filesys%==fat32 && set result= && set hexview=N && goto :endlocal
if %getfree3%==Y && if /i %filesys%==fat32 && call :getfreeclustersfat32 &; if %getfree3%==Y && set clusfree=%clusfree% ! if %getfreeB%==Y && set clusfree=%clusfrFS% &; if exist clusfree && set /a result=%clusfree% * %clussize% ! set result= &; set hexview=N && goto :endlocal
if %getnext3%==Y && if /i %filesys%==fat32 && setlocal && set /a fatsize=%numclus% * 4 + 8 && call :endoffreeclustersfat32 "goback" &; endlocal && set result=%nextfree% && set hexview=N && goto :endlocal
if /i %filesys%==fat32 && call :FSinfo &; if not %getfreeB%==Y if not %getnext%==Y |; if %getfreeB%==Y && set clusfree=%clusfrFS% ! if %getnext%==Y && set result=%nextfrFS% &; if exist clusfree && set /a result=%clusfree% * %clussize% ! if %getfreeB%==Y && set result= ! set result=%result% &; set hexview=N && goto :endlocal
## Last time var RD is used
call :fatintegritytest &; set RD= && if %result%==0 && if not %test%==Y && set hexview=N && goto :endlocal
call :getbootcode &; if not exist bootcode && set bootcode=Unknown
if %getbootc%==Y && endlocal && set result=%bootcode% && set hexview=N && goto :endlocal
#DEGUB#echo "if %getvars%==Y && endlocal && set FILESYS=%filesys% && set BYTEPSEC=%bytepsec% && set SECPCLUS=%secpclus% && set RESERVED=%reserved% && set NUMFATS=%numfats% && set SECPFAT=%secpfat% && set SECTRACK=%sectrack% && set NUMHEADS=%numheads% && set ROOTENTR=%rootentr% && set DEVSECT=%devsect% && set MEDIABYT=%mediabyt% && set UUID=%uuid% && set "BOOTCODE=%bootcode%" && set CLUSFREE=%clusfrFS% && set NEXTFREE=%nextfrFS% &; if exist FILESYS && if exist BYTEPSEC && if exist SECPCLUS && if exist RESERVED && if exist NUMFATS && if exist SECPFAT && if exist SECTRACK && if exist NUMHEADS && if exist ROOTENTR && if exist DEVSECT && if exist MEDIABYT && if exist UUID && if exist BOOTCODE && if exist CLUSFREE && if exist NEXTFREE && set result=1 ! set result=0 &; goto :endlocal
if %getvars%==Y && if /i %filesys%==fat32 && endlocal && set FILESYS=%filesys% && set BYTEPSEC=%bytepsec% && set SECPCLUS=%secpclus% && set RESERVED=%reserved% && set NUMFATS=%numfats% && set SECPFAT=%secpfat% && set SECTRACK=%sectrack% && set NUMHEADS=%numheads% && set ROOTENTR=%rootentr% && set DEVSECT=%devsect% && set MEDIABYT=%mediabyt% && set UUID=%uuid% && set "BOOTCODE=%bootcode%" && set CLUSFREE=%clusfrFS% && set NEXTFREE=%nextfrFS% &; if exist FILESYS && if exist BYTEPSEC && if exist SECPCLUS && if exist RESERVED && if exist NUMFATS && if exist SECPFAT && if exist SECTRACK && if exist NUMHEADS && if exist ROOTENTR && if exist DEVSECT && if exist MEDIABYT && if exist UUID && if exist BOOTCODE && if exist CLUSFREE && if exist NEXTFREE && set result=1 ! set result=0 &; set hexview=N && goto :endlocal
if %getvars%==Y && if not /i %filesys%==fat32 && endlocal && set FILESYS=%filesys% && set BYTEPSEC=%bytepsec% && set SECPCLUS=%secpclus% && set RESERVED=%reserved% && set NUMFATS=%numfats% && set SECPFAT=%secpfat% && set SECTRACK=%sectrack% && set NUMHEADS=%numheads% && set ROOTENTR=%rootentr% && set DEVSECT=%devsect% && set MEDIABYT=%mediabyt% && set UUID=%uuid% && set "BOOTCODE=%bootcode%" && set CLUSFREE=%clusfrFS% && set NEXTFREE=%nextfrFS% &; if exist FILESYS && if exist BYTEPSEC && if exist SECPCLUS && if exist RESERVED && if exist NUMFATS && if exist SECPFAT && if exist SECTRACK && if exist NUMHEADS && if exist ROOTENTR && if exist DEVSECT && if exist MEDIABYT && if exist UUID && if exist BOOTCODE && set result=1 ! set result=0 &; set hexview=N && goto :endlocal
#ALWAYSTEST#
if not exist FILE && setlocal && set "NULL= > nul" && call :BPB_totalsectortest &; endlocal && set totsecOK=%totsecOK%
#ALWAYSTEST#
if exist FILE && setlocal && set "NULL= > nul" && call :BPB_imagesectortest &; endlocal && set totsecOK=%totsecOK%
if not %test%==Y && if /i %filesys%==fat16 && if %totsecOK%==Y && call :getfreeclustersfat16 &; if not %getfreeB%==Y if not %getnext%==Y |; if %getfreeB%==Y && set clusfree=%clusfree% ! if %getnext%==Y && set result=%nextfree% && set clusfree= &; if exist clusfree && set /a result=%clusfree% * %clussize% ! if %getnext%==Y && set result=%result% &; set hexview=N && goto :endlocal
if not %test%==Y && if /i %filesys%==fat12 && if %totsecOK%==Y && call :getfreeclustersfat12 &; if not %result%==0 &; if not %getfreeB%==Y if not %getnext%==Y |; if %getfreeB%==Y && set clusfree=%clusfree% ! if %getnext%==Y && set result=%nextfree% && set clusfree= &; if exist clusfree && set /a result=%clusfree% * %clussize% ! if %getnext%==Y && set result=%result% &; set hexview=N && goto :endlocal
if not %test%==Y && if /i %filesys%==fat32 && if %clusfrFS%>=0xFFFFFFFE && if %totsecOK%==Y && setlocal && call :getfreeclustersfat32 &; endlocal && set clusfree=%clusfree%
if not %test%==Y && if /i %filesys%==fat32 && if %nextfrFS%>=0xFFFFFFFE && if %totsecOK%==Y && setlocal && set /a fatsize=%numclus% * 4 + 8 && call :endoffreeclustersfat32 "goback" &; endlocal && set nextfree=%nextfree%
if not %test%==Y && if %getbadsc%==Y && if /i %filesys%==fat12 && if %totsecOK%==Y && call :getbadclustersfat12 &; set result=%clusbad% && set hexview=N && goto :endlocal
if not %test%==Y && if %getbadsc%==Y && if /i %filesys%==fat16 && if %totsecOK%==Y && call :getbadclustersfat16 &; set result=%clusbad% && set hexview=N && goto :endlocal
if not %test%==Y && if %getbadsc%==Y && if /i %filesys%==fat32 && if %totsecOK%==Y && call :getbadclustersfat32 &; set result=%clusbad% && set hexview=N && goto :endlocal
if not %test%==Y &; if not %result%==0 && call :fatinfo && goto :endlocal ! goto :endlocal
if not %result%==0 && set result=1
## Last time var rootorg is used
if not exist FILE && call :BPB_totalsectortest ! call :BPB_imagesectortest &; set rootorg=
## Last time var mediaok is used
call :checkmediabyte &; if not exist filesys && set result=0 ! if %mediaoke%==N && set result=0 &; set mediaok=
call :CHSLBAbalancetest
call :BS_signaturetest
if /i %filesys%==fat32 && if exist backsect && call :fat32backuptest
call :checksecpfat
if not /i %filesys%==fat12 && call :getshutdownflag
call :checkfatstart
if not %reserve1%==0 && if %BSdrvnum%<=0x9E && if not %BSdrvnum%==0x21 && if not %BSdrvnum%==0x23 && echo Demounting: dirty (%reserved1%) - maybe USB pen drive%NULL% && set result=0
if %numfats%>=2 && call :comparefat1fat2
if /i %filesys%==fat32 && if %totsecOK%==Y && setlocal && call :getfreeclustersfat32 &; if not exist result && echo $[0x0F]Count of free clusters is unknown%NULL% && endlocal && set nextfree=%nextfree% ! if exist clusfree && if %clusfree%==%clusfrFS% && echo Count of free clusters is same as FSInfo (%clusfree%)%NULL% && endlocal && set nextfree=%nextfree% ! if not %clusfrFS%>=0xFFFFFFE && echo Count of free clusters (%clusfree%) is NOT same as FSInfo (%clusfrFS%)%NULL% && endlocal && set nextfree=%nextfree% ! echo Count of free clusters is %clusfree% - FSInfo is unknown%NULL% && endlocal && set nextfree=%nextfree%
if /i %filesys%==fat32 && if not %totsecOK%==Y &; if not %disk%==Y && if not exist rdsect && echo $[0x0F]Count of free clusters can not be tested%NULL% && set result=0 ! if exist rdsect && echo $[0x0F]Count of free clusters can not be tested: ram-disk too small%NULL% && set result=0 ! echo $[0x0F]Count of free clusters can not be tested: blocklist too short%NULL% && set result=0
if /i %filesys%==fat32 && if %totsecOK%==Y && if exist nextfree && set /a nextfrCN=%nextfree%-1 &; if %nextfrCN%==%nextfrFS% && echo First next-free cluster is same as FSInfo (%nextfrCN%)%NULL% ! if exist nextfrFS && if not %nextfrFS%>=0xFFFFFFE && if not %nextfrCN%==%nextfrFS% && echo First next-free cluster (%nextfrCN%) is NOT same as FSInfo (%nextfrFS%)%NULL% ! echo First next-free cluster is %nextfrCN% - FSInfo is unknown%NULL%
if /i %filesys%==fat32 && if not %totsecOK%==Y &; if not exist nextfree && echo $[0x0F]Next-free cluster is unknown%NULL% && set result=0 ! if not %disk%==Y && if not exist rdsect && echo $[0x0F]Next-free cluster can not be tested%NULL% && set result=0 ! if exist rdsect && echo $[0x0F]Next-free cluster can not be tested: ram-disk too small%NULL% && set result=0 ! echo $[0x0F]Next-free cluster can not be tested: blocklist too short%NULL% && set result=0
if /i %filesys%==fat12 && if %totsecOK%==Y && call :getbadclustersfat12 &; if %getbadB%==Y && set result=%clusbad% && set hexview=N && goto :endlocal
if /i %filesys%==fat16 && if %totsecOK%==Y && call :getbadclustersfat16 &; if %getbadB%==Y && set result=%clusbad% && set hexview=N && goto :endlocal
if /i %filesys%==fat32 && if %totsecOK%==Y && call :getbadclustersfat32 &; if %getbadB%==Y && set result=%clusbad% && set hexview=N && goto :endlocal
if exist clusbad &; if %clusbad%==0 && echo Number of clusters marked as bad: %clusbad%%%NULL% ! echo $[0x0F]Number of clusters marked as bad: %clusbad%%%NULL% && set result=0 &; if %getbadcl%==Y && set result=%clusbad% && set hexview=N && goto :endlocal
#BAD#if exist clusbad &; if %clusbad%==0 && echo Number of clusters marked as bad: %clusbad%%%NULL% ! echo $[0x0F]Number of clusters marked as bad: %clusbad%%%NULL% && set result=0
setlocal && set /a bytedata=%devsect% * %bytepsec% - %dataarea% && set /a byteclus=%numclus% * %clussize% &; endlocal && set /a paddsect=%bytedata%-%byteclus%/%bytepsec% &; if %paddsect%>=0 && echo Number of padding sectors: %paddsect%%%NULL% ! echo $[0x0F]Number of padding sectors: %paddsect% - BUG, please report! && set result=0
#BAD#setlocal && set /a bytedata=%devsect% * %bytepsec% - %dataarea% && set /a byteclus=%numclus% * %clussize% &; endlocal && set /a paddsect=%bytedata%-%byteclus%/%bytepsec% &; if %paddsect%>=0 && echo Number of padding sectors: %paddsect% ! echo $[0x0F]Number of padding sectors: %paddsect% - BUG, please report! && set result=0
if %result%==1 && echo All tests: PASSED%NULL% ! if %result%==0 && echo All tests: $[0x0F]NOT PASSED%NULL% ! echo Not all tests possible%NULL%
:endlocal
if %hexview%==Y && call :hexview &; if exist pagersts &; if %pagersts%==1 && pager on ! pager off
set hexview=
debug %debugsts%
debug msg=3
if not %getvars%==Y && endlocal && set "result=%result%"
if %getvars%==Y && endlocal && set "result=%result%" && set FILESYS=%FILESYS% && set BYTEPSEC=%BYTEPSEC% && set SECPCLUS=%SECPCLUS% && set RESERVED=%RESERVED% && set NUMFATS=%NUMFATS% && set SECPFAT=%SECPFAT% && set SECTRACK=%SECTRACK% && set NUMHEADS=%NUMHEADS% && set ROOTENTR=%ROOTENTR% && set DEVSECT=%DEVSECT% && set MEDIABYT=%MEDIABYT% && set UUID=%UUID% && set "BOOTCODE=%BOOTCODE%" && set CLUSFREE=%CLUSFREE% && set NEXTFREE=%NEXTFREE%
goto :eof
::-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
:: SUB-ROUTINES
::-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
:getCDtotsec
if %CDtotsec%==0 && raw cat --hex --length=1 %device%%%CDtotsec%+1 > nul || set CDtotsec= && goto :eof
if not %diffsec%>=1 if not %diff2sec%>=1 |; raw cat --hex --length=1 %device%%%CDtotsec%+1 > nul && set /A CDtotsec=%CDtotsec%+%diffsec% && set /A diff2sec=%diffsec%/2 && goto :getCDtotsec ! set /A CDtotsec=%CDtotsec%-%diff2sec% && set /A diffsec=%diff2sec%/2 && goto :getCDtotsec
setlocal && set /A lastsec=%CDtotsec%+1 &; raw cat --hex --length=1 %device%%%CDtotsec%+1 > nul && endlocal && set CDtotsec=%lastsec% ! endlocal
set diffsec= && set diff2sec=
goto :eof
::
:fatintegritytest
setlocal
if %disk%==Y &; if %CDROM%==Y && set /a sectors=%devsect%/4 ! if not "%FILE:~0,3%"=="(rd" && set sectors=%devsect%
if %offset%==0 && set offset=
if exist FILE && echo -e "%FILE%" | set ECHOFILE= &; set "ECHOFILE=%ECHOFILE:~1,-1%" &; set /a echolen=%@retval%
if exist RD && if %block%==Y && echo -n Filesystem on [%RD%]: %filesys%%%NULL% ! if exist RD && if %disk%==Y && echo -n Filesystem on [%RD%+%sectors%]: %filesys%%%NULL% ! if not exist FILE && echo -n Filesystem on %device%: %filesys%%%NULL% ! if %echolen%<=40 && echo -n -e Filesystem on %FILE%: %filesys%%%NULL% ! echo -n -e Filesystem on %ECHOFILE:~0,25%...%ECHOFILE:~-12,12%: %filesys%%%NULL% &; if %startsec%>=1 && if %CDROM%==Y && if exist RD && if exist offset && call Fn.11 "%RD%" ")%CDstart%" && set /A OFFSET=%offset% ! if %startsec%>=1 && if %CDROM%==Y && if exist offset && set /A OFFSET=%CDstart% * 2k + %offset% ! if %startsec%>=1 && if %CDROM%==Y && if exist RD && call Fn.11 "%RD%" ")%CDstart%" && set OFFSET=0 ! if %startsec%>=1 && if %CDROM%==Y && set /a OFFSET=%CDstart% ! if %startsec%>=1 && if exist RD && call Fn.11 "%RD%" ")%startsec%" && set OFFSET=0 ! set OFFSET=%startsec% &; if %startsec%>=1 && if exist offset && echo -e \x20at offset %OFFSET%%%NULL% ! if %startsec%>=1 && echo -e \x20at sector %OFFSET%%%NULL% ! echo%NULL% &; set OFFSET= && set ECHOFILE= && set echolen=
set /A base=%mdbase% * 0x200
if %test%==Y && set color=$[0x0F] ! set color=$[]
#bytepsec#
if %bytepsec%==0 && echo %color%Number of Bytes per Sector is zero%NULL% && set result=0
calc %bytepsec% % 32 && echo %color%Number of Bytes per Sector '%bytepsec%' is not a multiple of 32%NULL% && set result=0
if not %bytepsec%<=32k && echo %color%Number of Bytes per Sector '%bytepsec%' out of range%NULL% && set result=0
if %devsect%<=65535 && if not %bytepsec%>=32 && echo %color%Number of Bytes per Sector '%bytepsec%' out of range%NULL% && set result=0
if not %devsect%<=65535 && if not %bytepsec%>=64 && echo %color%Number of Bytes per Sector '%bytepsec%' out of range%NULL% && set result=0
#secpclus#
if %secpclus%==0 && echo %color%Number of Sectors per Cluster is zero%NULL% && set result=0
calc %secpclus% % 2 && && echo %color%Number of Sectors per Cluster '%secpclus%' is invalid%NULL% && set result=0
if %bytepsec%==512 && if not %secpclus%<=64k && echo %color%Number of Sectors per Cluster '%secpclus%' out of range%NULL% && set result=0
if %bytepsec%==1k && if not %secpclus%<=128k && echo %color%Number of Sectors per Cluster '%secpclus%' out of range%NULL% && set result=0
if %bytepsec%>=2k && if not %secpclus%<=256k && echo %color%Number of Sectors per cluster '%secpclus%' out of range%NULL% && set result=0
#reserved#
if %reserved%==0 && echo %color%Number of reserved sectors is zero%NULL% && set result=0
#numfats#
if %numfats%==0 && echo %color%Number of FAT's is zero%NULL% && set result=0
#rootentr#
if not /i %filesys%==fat32 && if %rootentr%==0 && echo %color%Number of Root Entries is zero%NULL% && set result=0
if /i %filesys%==fat32 && if not %rootentr%==0 && echo %color%Number of Root Entries is not zero%NULL% && set result=0
#mediabyt#
if not %test%==Y && checkrange 0xE5:0xFF calc %mediabyt% || echo %color%Media Type '%mediabyt%' is invalid%NULL% && set result=0
#Test of fatstart: No Shutdown Byte test here on Fat16/32!#
if not %test%==Y && set /A fatskip=%reserved% * %bytepsec%
if not %test%==Y && setlocal && call :readdisk "%fatskip%" &; set FATmedia=0x%result:~-2,2% &; if not /i %filesys%==fat32 && set FATbytes=%result:~-6,4% ! set FATbytes=%result:~-8,6% &; endlocal && set FATmedia=%FATmedia% && set FATbytes=%FATbytes%
if not %test%==Y && checkrange 0xE5:0xFF calc %FATmedia% || echo %color%Media Type '%FATmedia%' is invalid in start of FAT%NULL% && set result=0
if not %test%==Y &; if /i %filesys%==fat12 && if not /i %FATbytes%==FFFF && echo '%FATmedia:~2%%%FATbytes%' is invalid as start of FAT%NULL% && set result=0
if not %test%==Y &; if /i %filesys%==fat16 && if not /i %FATbytes:~2,2%==FF && echo '%FATmedia:~2%%%FATbytes%' is invalid as start of FAT%NULL% && set result=0
if not %test%==Y &; if /i %filesys%==fat32 && if not /i %FATbytes:~1,5%==FFFFF && echo '%FATmedia:~2%%%FATbytes%' is invalid as start of FAT%NULL% && set result=0
#secpfat#
#DEBUG#if not %test%==Y && if /i %filesys%==fat12 && set /a FATsec=%numclus% * 3 + 1 / 2 + 3 &; echo I FATsec=%FATsec% && set /a FATsec=%FATsec%>>9 &; echo II FATsec=%FATsec% && if not %FATsec%<=%secpfat% && echo %color%Number of Sectors per FAT '%secpfat%' is too low%NULL% && set result=0
#MAYBEBADTOO#if not %test%==Y && if /i %filesys%==fat12 && set /a FATsec=%numclus% * 3 + 1 / 2 + 3 &; set /a FATsec=%FATsec%>>9 &; if not %FATsec%<=%secpfat% && echo %color%Number of Sectors per FAT '%secpfat%' is too low%NULL% && set result=0
if not %test%==Y && if /i %filesys%==fat12 && set /a FATsec=%numclus% * 3 / 2 + 3 &; calc %FATsec% % 512 || set /a FATsec=%FATsec%>>9 ! set /a FATsec=%FATsec%>>9+1 &; if not %FATsec%<=%secpfat% && echo %color%Number of Sectors per FAT '%secpfat%' is too low with %numclus% clusters%NULL% && set result=0
if not %test%==Y && if /i %filesys%==fat16 && set /a FATsec=%numclus% * 2 + 4 &; calc %FATsec% % 512 || set /a FATsec=%FATsec%>>9 ! set /a FATsec=%FATsec%>>9+1 &; if not %FATsec%<=%secpfat% && echo %color%Number of Sectors per FAT '%secpfat%' is too low with %numclus% clusters%NULL% && set result=0
if not %test%==Y && if /i %filesys%==fat32 && set /a FATsec=%numclus% * 4 + 8 &; calc %FATsec% % 512 || set /a FATsec=%FATsec%>>9 ! set /a FATsec=%FATsec%>>9+1 &; if not %FATsec%<=%secpfat% && echo %color%Number of Sectors per FAT '%secpfat%' is too low with %numclus% clusters%NULL% && set result=0
#sectrack#
#IsReserved#if %sectrack%==0 && echo %color%Number of Sectors per Track is zero && set result=0
if not %sectrack%<=63 && echo %color%Number Sectors per Track '%sectrack%' is out of range%NULL% && set result=0
#IsReserved#if %numheads%==0 && echo %color%Number of Heads is zero%NULL% && set result=0
if not %numheads%<=255 && echo %color%Number of Heads '%numheads%' is out of range%NULL% && set result=0
#FAT32 specific#
if /i %filesys%==fat32 && set /A address=%base%+0x2C &; read %address% &; set /A rootclus=%@retval%&0xffffffff &; if not %rootclus%>=2 && echo %color%Number of Root Clusters is below 2%NULL% && set result=0
if /i %filesys%==fat32 && cat --skip=0x34 --locate=\x00 --length=12 (md)%mdbase%+1 > nul &; if not %@retval%==12 && echo %color%Reserved bytes at 0x34-0x3F not all zero%NULL% && set result=0
#extbtsig#
if /i %filesys%==fat32 && if not %extbtsig%==0x29 && if not %extbtsig%==0x28 && echo %color%Extended Bios Parameter Block Signature '%extbtsig%' is not valid%NULL% && set result=0
#filesys#
if not /i %filesys%==fat32 && cat --skip=0x36 --length=8 (md)%mdbase%+1 | set FILESYS= &; if %extbtsig%==0x29 && if not /i %FILESYS:~0,3%==FAT && echo %color%File System Type '%FILESYS%' is invalid%NULL% && set result=0
if /i %filesys%==fat32 && cat --skip=0x52 --length=8 (md)%mdbase%+1 | set FILESYS= &; if not /i %FILESYS:~0,3%==FAT && echo %color%File System Type '%FILESYS%' is invalid%NULL% && set result=0
#LEAVE#
if %test%==Y && endlocal && set result=%result% && goto :eof
#magicbyt#
set /A address=%base%+0x1FE &; read %address% &; set /A magicbyt=%@retval%&0xffff &; if not %magicbyt%==0xAA55 && echo %color%Boot Signature '%magicbyt%' is invalid%NULL% && set result=0
endlocal && set result=%result%
goto :eof
::
:fatinfo
setlocal
if not %extbtsig%==0x29 if not %extbtsig%==0x28 |; if exist uuid && echo UUID: %uuid% ! echo -e UUID: N/A
if not %extbtsig%==0x29 && if not %extbtsig%==0x28 && echo -e BPB Version\x20<\x204.0: no UUID or Volume Label
if not %extbtsig%==0x29 if not %extbtsig%==0x28 |; if exist bootvol && echo Volume name in bootsector: %bootvol% ! echo Volume name in bootsector: N/A
if exist jmpBoot && echo Jump instruction: %jmpBoot% (%jmpBoot:~-2,2%%%jmpBoot:~-4,2%%%jmpBoot:~-6,2%) ! echo Boot signature: empty
if not exist OEMName && echo OEM: unknown  Bootcode: %bootcode% ! echo OEM: %OEMName%  Bootcode: %bootcode%
echo Number of bytes per sector: %bytepsec%
echo Number of sectors per cluster: %secpclus%
echo Number of reserved sectors: %reserved%
echo Number of FAT's: %numfats%
if not /i %filesys%==fat32 && echo Number of root entries: %rootentr%
echo Media descriptor: %mediabyt%
if not /i %filesys%==fat32 && if %secpfat%<=0xFFFF && echo Number of sectors per FAT: %secpfat%
echo Sectors per track: %sectrack%
echo Number of heads: %numheads%
if %hiddsect%==0 &; echo Number of hidden sectors before: %hiddsect%
if not %hiddsect%==0 &; echo Number of hidden sectors before: %hiddsect%
echo Total number of sectors: %devsect%
if not %secpfat%>=0x10000 if not /i %filesys%==fat32 || echo Number of sectors per FAT: %secpfat%
if not %extbtsig%==0x28 if not %extbtsig%==0x29 |; if %BSdrvnum%<=0x7E && if not %BSdrvnum%==0x21 && if not %BSdrvnum%==0x23 && echo Drive type: removable ! if %BSdrvnum%==0x21 && echo Drive type: network boot device (pxe) ! if %BSdrvnum%==0x23 && echo Drive type: Fbinst hidden partition (ud) ! if %BSdrvnum%==0x7F && echo Drive type: random memory storage ! if %BSdrvnum%>=0x80 && if %BSdrvnum%<=0x9F && echo Drive type: fixed ! echo Drive type: unknown
if not %extbtsig%==0x28 && if not %extbtsig%==0x29 &; if %hiddsect%>=1 && echo Drive type: unknown, probably fixed ! echo Drive type: unknown, probably removable
echo Total number of clusters: %numclus%
if /i %filesys%==fat32 && echo FSinfo sector is sector: %FSinfosc%
if /i %filesys%==fat32 &; if exist backsect && echo Backup of bootsectors starts at sector: %backsect% ! echo Backup of bootsectors: none
if not /i %filesys%==fat32 &; if %totsecOK%==Y && echo Number of free clusters: %clusfree% ! echo Number of free clusters: Unknown
if not /i %filesys%==fat32 &; if %nextfree%>=3 && set /a clusnumN=%nextfree%-1 ! set clusnumN= &; if %totsecOK%==Y && if exist clusnumN && echo First next-free: %clusnumN% ! if %totsecOK%==Y && if %nextfree%==2 && echo First next-free cluster: All free ! echo First next-free cluster: Unknown
if /i %filesys%==fat32 &; if %totsecOK%==Y &; if %clusfrFS%<=0xFFFFFFFD && echo Number of free clusters (FSinfo): %clusfrFS% ! if exist clusfree && echo Number of free clusters: %clusfree% (FSinfo: Unknown) ! echo Number of free clusters (FSinfo): Unknown
if /i %filesys%==fat32 &; if %nextfrFS%>=2 && if %nextfrFS%<=0xFFFFFFD && echo First root cluster: %ROOTclus%  Next-free cluster (FSinfo): %nextfrFS% ! if exist nextfree && echo First root cluster: %ROOTclus%  First next-free cluster: %nextfree% (FSinfo unknown) ! echo First root cluster: %ROOTclus%  Next-free cluster (FSinfo): Unknown
if not /i %filesys%==fat32 && set /a drvspace=%numclus% * %clussize% &; set /a drvspcKB=%drvspace%>>10 &; if %totsecOK%==Y && echo Total drive space: %drvspace% (%drvspcKB% KB) ! echo Total drive space: Unknown
if /i %filesys%==fat32 && set /a drvspace=%numclus% * %clussize% &; if %clussize%>=1k && set /a drvspcKB=%clussize% / 1k * %numclus% ! set /a drvspcKB=%drvspace%>>10 &; echo Total drive space: %drvspace% (%drvspcKB% KB)
if /i %filesys%==fat12 && set /a freespac=%clusfree% * %clussize% &; set /a freespKB=%freespac%>>10 &; if %totsecOK%==Y && echo Available drive space: %freespac% (%freespKB% KB) ! echo Available drive space: Unknown
if /i %filesys%==fat16 && set /a freespac=%clusfree% * %clussize% &; set /a freespKB=%freespac%>>10 &; if %totsecOK%==Y && echo Available drive space: %freespac% (%freespKB% KB) ! echo Available drive space: Unknown
if /i %filesys%==fat32 && if %clusfrFS%<=0xFFFFFFD && set /a freespac=%clusfrFS% * %clussize% &; if %clussize%>=1k && set /a freespKB=%clussize% / 1k * %clusfrFS% ! set /a freespKB=%freespac%>>10 &; echo Available drive space: %freespac% (%freespKB% KB)
if /i %filesys%==fat32 && if %clusfrFS%>=0xFFFFFFE && set /a freespac=%clusfree% * %clussize% &; if %clussize%>=1k && set /a freespKB=%clussize% / 1k * %clusfree% ! set /a freespKB=%freespac%>>10 &; if exist clusfree && echo Available drive space: %freespac% (%freespKB% KB) ! echo Available drive space: Unknown
if exist device && raw dd if=%device%%%reserved%+1 of=(md)%mdbase%+1 > nul
if exist FILE && if %disk%==Y && if %devsect%<=%reserved% && echo $[0x0F]Start of FAT is not available in %FILE% && endlocal && goto :eof
if exist FILE && if not %disk%==Y && set /a rsrvbyte=%reserved% * %bytepsec% &; if %filesize%<=%rsrvbyte% && echo $[0x0F]Start of FAT is not available in %FILE% && endlocal && goto :eof
#BAD#if exist FILE && if %disk%==Y && set /a skip=%startsec%+%reserved% &; if %skip%<=%reserved% && echo $[0x0F]Start of FAT is not available in %FILE% && endlocal && goto :eof
if exist FILE && if %disk%==Y && set /a skip=%startsec% * 512 &; set /a skip=%reserved% * %bytepsec% + %skip% &; raw dd if=%FILE% of=(md)%mdbase%+1 bs=1 count=512 skip=%skip% > nul
if exist FILE && if not %disk%==Y && set /a skip=%hiddsect%+%reserved% &; raw dd if=%FILE% of=(md)%mdbase%+1 count=1 skip=%skip% > nul
set /A base=%mdbase% * 0x200
read %base% &; set /A startfat=%@retval%&0xff &; if not %startfat%==%mediabyt% && echo $[0x0F]Media Type '%mediabyt%' is not start of FAT
endlocal
goto :eof
::
:getfreeclustersfat16
if not %secpfat%<=256 &; if not %test%==Y && echo Abort %0 => Sectors per FAT on FAT16: %secpfat%>256%NULL% ! set test=%test% &; goto :eof
setlocal
set /a fatsize=%numclus% * 2 + 4
set /a secpfat=%fatsize%/%bytepsec% &; calc %fatsize% % %bytepsec% && set /a secpfat=%secpfat%+1
set devfat1=%reserved%
set mdfat1=%mdbase%
set /a fullsect=%secpfat%-1
echo -n > (md)%mdfat1%+%secpfat%
if not exist FILE && raw dd if=%device%%%devfat1%+%secpfat% of=(md)%mdfat1%+%secpfat% bs=1 count=%fatsize% > nul
if exist FILE && set /A fileskip=%startsec% * 512 &; set /A fileskip=%devfat1% * %bytepsec% + %fileskip% &; raw dd if=%FILE% of=(md)%mdfat1%+%secpfat% bs=1 count=%fatsize% skip=%fileskip% > nul
set clusfree=0
set /a maxfree=%bytepsec%/2
set leftlen=%bytepsec%
set leftmax=%bytepsec%
set secttodo=1
#InsertWait...#
call Fn.4 ;; set /a v=%@retval%>>8 ;; call Fn.5 0 %v% ;; echo -n -e \x20$[0x0F]Counting free clusters...%NULL%
:freeclustersfat16loop
set skip=0
set freeinSC=0
if %secttodo%==%secpfat% && set /a leftlen=-%secpfat% + 1 * %bytepsec% + %fatsize% && set /a leftmax=-%secpfat% + 1 * %bytepsec% + %fatsize% && set /a maxfree=-%secpfat% + 1 * %bytepsec% + %fatsize% / 2
raw cat --skip=%skip% --locate=\x00\x00 --length=%leftlen% (md)%mdfat1%+1 > nul &; set /a freeinSC=%@retval%
if %freeinSC%==0 &; if not %secttodo%>=%secpfat% && set /a secttodo=%secttodo%+1 && set /A mdfat1=%mdfat1%+1 && goto :freeclustersfat16loop ! goto :endoffreeclustersfat16
if %freeinSC%==%maxfree% && set /a clusfree=%clusfree%+%maxfree% &; if not %secttodo%>=%secpfat% && set /a secttodo=%secttodo%+1 && set /A mdfat1=%mdfat1%+1 && goto :freeclustersfat16loop ! goto :endoffreeclustersfat16
:freeclustersinsecfat16loop
raw cat --skip=%skip% --locate=\x00\x00 --length=%leftlen% --number=1 (md)%mdfat1%+1 | set nextfree= &; if exist nextfree && set /a nextfree=0x%nextfree%
if exist nextfree && calc %nextfree% % 2 && set /a leftlen=%leftmax%-%nextfree%-1 && set /a skip=%nextfree%+1
if exist nextfree && calc %nextfree% % 2 || set /a clusfree=%clusfree%+1 && set /a leftlen=%leftmax%-%nextfree%-2 && set /a skip=%nextfree%+2
if exist nextfree && set nextfree= && if %leftlen%>=2 && goto :freeclustersinsecfat16loop
if not exist nextfree && if not %secttodo%>=%secpfat% && set /a secttodo=%secttodo%+1 && set /A mdfat1=%mdfat1%+1 && set leftlen=%bytepsec% && set leftmax=%bytepsec% && goto :freeclustersfat16loop
:endoffreeclustersfat16
set nextfree=
set skip=4
set /a leftlen=%fatsize%-4
:nextfreeclusterfat16loop
raw cat --skip=%skip% --locate=\x00\x00 --length=%leftlen% --number=1 (md)%mdbase%+%secpfat% > nul &; set /a nextfree=%?%
calc %nextfree% % 2 && set /a leftlen=%leftlen%-%skip%-1 && set /a skip=%nextfree%+1 && goto :nextfreeclusterfat16loop
call Fn.5 0 %v% ;; echo -n -e \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20%NULL% ;; call Fn.5 0 %v%
if %nextfree%>=2 && set /a nextfree=%nextfree%/2
endlocal && set clusfree=%clusfree% && set nextfree=%nextfree%
goto :eof
::
:getfreeclustersfat32
setlocal && set * && set mdbase=%mdbase% && set device=%device% && set devsect=%devsect% && set bytepsec=%bytepsec% && set reserved=%reserved% && set secpfat=%secpfat% && set numclus=%numclus% && set test=%test% && set "FILE=%FILE%" && set startsec=%startsec% && set "NULL=%NULL%" && set disk=%disk%
set secpfat0=%secpfat%
set /a fatsize=%numclus% * 4 + 8
set /a secpfat=%fatsize%/%bytepsec% &; calc %fatsize% % %bytepsec% && set /a secpfat=%secpfat%+1
if not %secpfat%<=%secpfat0% && endlocal && set result= && goto :eof
set devfat1=%reserved%
set mdfat1=%mdbase%
set /a fullsect=%secpfat%-1
set leftsec=%secpfat%
set clusfree=0
set /a maxfree=%bytepsec%/4
set leftlen=%bytepsec%
set leftmax=%bytepsec%
set secttodo=1
#InsertWait...#
if %test%==Y && call Fn.4 ;; set /a v=%@retval%>>8 ;; if %test%==Y && call Fn.5 0 %v% ;; if %test%==Y && echo -n -e \x20$[0x0F]Counting free clusters...%NULL%
:ddcopyloopfat32
if %leftsec%>=255 && set copysec=255 ! set copysec=%leftsec%
echo -n > (md)%mdfat1%+%copysec%
if not exist FILE && raw dd if=%device%%%devfat1%+%copysec% of=(md)%mdfat1%+%copysec% > nul
if exist FILE && set /a sectskip=%startsec% * 512 &; set /a sectskip=%devfat1% * %bytepsec% + %sectskip% && set /a copybyte=%copysec% * %bytepsec% &; raw dd if=%FILE% of=(md)%mdfat1%+%copysec% bs=1 count=%copybyte% skip=%sectskip% > nul
set /a leftsec=%leftsec%-%copysec%
set sectdone=0
:freeclustersfat32loop
if %sectdone%==%copysec% &; if %leftsec%>=1 && set /A devfat1=%devfat1%+255 && set mdfat1=%mdbase% && goto :ddcopyloopfat32 ! goto :endoffreeclustersfat32
set skip=0
set freeinSC=0
if %secttodo%==%secpfat% && set /a leftlen=-%secpfat% + 1 * %bytepsec% + %fatsize% && set /a leftmax=-%secpfat% + 1 * %bytepsec% + %fatsize% && set /a maxfree=-%secpfat% + 1 * %bytepsec% + %fatsize% / 4
raw cat --skip=%skip% --locate=\x00\x00\x00\x00 --length=%leftlen% (md)%mdfat1%+1 > nul &; set /a freeinSC=%@retval%
set /a sectdone=%sectdone%+1
if %freeinSC%==0 &; if not %secttodo%>=%secpfat% && set /a secttodo=%secttodo%+1 && set /A mdfat1=%mdfat1%+1 && goto :freeclustersfat32loop ! goto :endoffreeclustersfat32
if %freeinSC%==%maxfree% && set /a clusfree=%clusfree%+%maxfree% &; if not %secttodo%>=%secpfat% && set /a secttodo=%secttodo%+1 && set /A mdfat1=%mdfat1%+1 && goto :freeclustersfat32loop ! goto :endoffreeclustersfat32
:freeclustersinsecfat32loop
raw cat --skip=%skip% --locate=\x00\x00\x00\x00 --length=%leftlen% --number=1 (md)%mdfat1%+1 | set nextfree= &; if exist nextfree && set /a nextfree=0x%nextfree%
if exist nextfree && calc %nextfree% % 4 && set /a leftlen=%leftmax%-%nextfree%-1 && set /a skip=%nextfree%+1
if exist nextfree && calc %nextfree% % 4 || set /a clusfree=%clusfree%+1 && set /a leftlen=%leftmax%-%nextfree%-4 && set /a skip=%nextfree%+4
if exist nextfree && set nextfree= && if %leftlen%>=4 && goto :freeclustersinsecfat32loop
if not exist nextfree && if not %secttodo%>=%secpfat% && set /a secttodo=%secttodo%+1 && set /A mdfat1=%mdfat1%+1 && set leftlen=%bytepsec% && set leftmax=%bytepsec% && goto :freeclustersfat32loop
:endoffreeclustersfat32
if %test%==Y && call Fn.5 0 %v% ;; if %test%==Y && echo -n -e \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20%NULL% ;; if %test%==Y && call Fn.5 0 %v%
set nextfree=
if not exist FILE && set skip=0 ! set /A skip=%startsec% + %reserved% * %bytepsec%
set /A leftlen=%fatsize%
:nextfreeclusterfat32loop
if not exist FILE && raw cat --skip=%skip% --locate=\x00\x00\x00\x00 --length=%leftlen% --number=1 %device%%%reserved%+%secpfat% > nul &; set /A nextfree=%?%
if exist FILE && raw cat --skip=%skip% --locate=\x00\x00\x00\x00 --length=%leftlen% --number=1 %FILE% > nul &; set /A nextfree=%?%
calc %nextfree% % 4 && set /A leftlen=%leftlen%-%skip%-1 && set /A skip=%nextfree%+1 && goto :nextfreeclusterfat32loop
if exist FILE && set /a nextfree=-%startsec% - %reserved% * %bytepsec% + %nextfree%
if %nextfree%>=4 && set /a nextfree=%nextfree%/4 ! set nextfree=
if %~1==goback &; if %nextfree%>=3 && if %nextfree%<=0xFFFFFFFD && set /a nextfree=%nextfree%-1 ! set nextfree= &; goto :eof
endlocal && set clusfree=%clusfree% && set nextfree=%nextfree%
goto :eof
::
:getfreeclustersfat12
if not %secpfat%<=12 &; if not %test%==Y && echo Abort: %secpfat% sectors per FAT on FAT12 (>12)%NULL% && set result=0 ! set test=%test% &; goto :eof
setlocal
set /a fatsize=%numclus% * 3 &; calc %fatsize% % 2 ;; set /a fatsize=%fatsize%/2+%@retval%+3
echo -n > (md)%mdbase%+%secpfat%
if not exist FILE && raw dd if=%device%%%reserved%+%secpfat% of=(md)%mdbase%+%secpfat% bs=1 count=%fatsize% > nul
if exist FILE && set /A fileskip=%startsec% * 512 &; set /A fileskip=%reserved% * %bytepsec% + %fileskip% &; raw dd if=%FILE% of=(md)%mdbase%+%secpfat% bs=1 count=%fatsize% skip=%fileskip% > nul
set clusfree=0
set address=3
#InsertWait...#
call Fn.4 ;; set /a v=%@retval%>>8 ;; call Fn.5 0 %v% ;; echo -n -e \x20$[0x0F]Counting free clusters...%NULL%
:freeclustersfat12loop
setlocal && set device=(md) && call :readdisk "%address%" "%mdbase%" "%secpfat%" &; endlocal && set result=%result% &; set /A evenclus=%result%&0xfff && set /A oddclus=%result%&0xffffff>>12
if %evenclus%==0 && set /a clusfree=%clusfree%+1 && if not %locked%==Y && set locked=Y && set /a nextfree=%address% * 2 / 3
if %oddclus%==0 && set /a clusfree=%clusfree%+1 && if not %locked%==Y && set locked=Y && set /a nextfree=%address% * 2 / 3 + 1
set /A address=%address%+3 &; if not %address%>=%fatsize% && set result= && set evenclus= && set oddclus= && goto :freeclustersfat12loop
call Fn.5 0 %v% ;; echo -n -e \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20%NULL% ;; call Fn.5 0 %v%
calc %numclus% % 2 && set /a clusfree=%clusfree%-1
if %nextfree%>=2 && set /a nextfree=%nextfree%
endlocal && set clusfree=%clusfree% && set nextfree=%nextfree%
goto :eof
::
:getbadclustersfat16
if not %secpfat%<=256 &; if not %test%==Y && echo Abort %0 => Sectors per FAT on FAT16: %secpfat%>256%NULL% ! set test=%test% &; goto :eof
setlocal
set /a fatsize=%numclus% * 2 + 4
set /a secpfat=%fatsize%/%bytepsec% &; calc %fatsize% % %bytepsec% && set /a secpfat=%secpfat%+1
set devfat1=%reserved%
set mdfat1=%mdbase%
set /a fullsect=%secpfat%-1
echo -n > (md)%mdfat1%+%secpfat%
if not exist FILE && raw dd if=%device%%%devfat1%+%secpfat% of=(md)%mdfat1%+%secpfat% bs=1 count=%fatsize% > nul
if exist FILE && set /A fileskip=%startsec% * 512 &; set /A fileskip=%devfat1% * %bytepsec% + %fileskip% &; raw dd if=%FILE% of=(md)%mdfat1%+%secpfat% bs=1 count=%fatsize% skip=%fileskip% > nul
set clusbad=0
set /a maxbad=%bytepsec%/2
set leftlen=%bytepsec%
set leftmax=%bytepsec%
set secttodo=1
#InsertWait...#
call Fn.4 ;; set /a v=%@retval%>>8 ;; call Fn.5 0 %v% ;; echo -n -e \x20$[0x0F]Counting bad clusters...%NULL%
:badclustersfat16loop
set skip=0
set badinSC=0
if %secttodo%==%secpfat% && set /a leftlen=-%secpfat% + 1 * %bytepsec% + %fatsize% && set /a leftmax=-%secpfat% + 1 * %bytepsec% + %fatsize% && set /a maxfree=-%secpfat% + 1 * %bytepsec% + %fatsize% / 2
raw cat --skip=%skip% --locate=\x7FF\xFF --length=%leftlen% (md)%mdfat1%+1 > nul &; set /a badinSC=%@retval%
if %badinSC%==0 &; if not %secttodo%>=%secpfat% && set /a secttodo=%secttodo%+1 && set /A mdfat1=%mdfat1%+1 && goto :badclustersfat16loop ! goto :endofbadclustersfat16
if %badinSC%==%maxbad% && set /a clusbad=%clusbad%+%maxbad% &; if not %secttodo%>=%secpfat% && set /a secttodo=%secttodo%+1 && set /A mdfat1=%mdfat1%+1 && goto :badclustersfat16loop ! goto :endofbadclustersfat16
:badclustersinsecfat16loop
raw cat --skip=%skip% --locate=\x7F\xFF --length=%leftlen% --number=1 (md)%mdfat1%+1 | set nextbad= &; if exist nextbad && set /a nextbad=0x%nextbad%
if exist nextbad && calc %nextbad% % 2 && set /a leftlen=%leftmax%-%nextbad%-1 && set /a skip=%nextbad%+1
if exist nextbad && calc %nextbad% % 2 || set /a clusbad=%clusbad%+1 && set /a leftlen=%leftmax%-%nextbad%-2 && set /a skip=%nextbad%+2
if exist nextbad && set nextbad= && if %leftlen%>=2 && goto :badclustersinsecfat16loop
if not exist nextbad && if not %secttodo%>=%secpfat% && set /a secttodo=%secttodo%+1 && set /A mdfat1=%mdfat1%+1 && set leftlen=%bytepsec% && set leftmax=%bytepsec% && goto :badclustersfat16loop
:endofbadclustersfat16
call Fn.5 0 %v% ;; echo -n -e \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20%NULL% ;; call Fn.5 0 %v%
endlocal && set clusbad=%clusbad%
goto :eof
::
:getbadclustersfat32
setlocal && set * && set mdbase=%mdbase% && set device=%device% && set devsect=%devsect% && set bytepsec=%bytepsec% && set reserved=%reserved% && set secpfat=%secpfat% && set numclus=%numclus% && set test=%test% && set "FILE=%FILE%" && set startsec=%startsec% && set "NULL=%NULL%" && set disk=%disk%
set secpfat0=%secpfat%
set /a fatsize=%numclus% * 4 + 8
set /a secpfat=%fatsize%/%bytepsec% &; calc %fatsize% % %bytepsec% && set /a secpfat=%secpfat%+1
if not %secpfat%<=%secpfat0% && endlocal && set result= && goto :eof
set devfat1=%reserved%
set mdfat1=%mdbase%
set /a fullsect=%secpfat%-1
set leftsec=%secpfat%
set clusbad=0
set /a maxbad=%bytepsec%/4
set leftlen=%bytepsec%
set leftmax=%bytepsec%
set secttodo=1
#InsertWait...#
if %test%==Y && call Fn.4 ;; set /a v=%@retval%>>8 ;; if %test%==Y && call Fn.5 0 %v% ;; if %test%==Y && echo -n -e \x20$[0x0F]Counting bad clusters...%NULL%
:ddcopyloopfat32badclus
if %leftsec%>=255 && set copysec=255 ! set copysec=%leftsec%
echo -n > (md)%mdfat1%+%copysec%
if not exist FILE && raw dd if=%device%%%devfat1%+%copysec% of=(md)%mdfat1%+%copysec% > nul
if exist FILE && set /a sectskip=%startsec% * 512 &; set /a sectskip=%devfat1% * %bytepsec% + %sectskip% && set /a copybyte=%copysec% * %bytepsec% &; raw dd if=%FILE% of=(md)%mdfat1%+%copysec% bs=1 count=%copybyte% skip=%sectskip% > nul
set /a leftsec=%leftsec%-%copysec%
set sectdone=0
:badclustersfat32loop
if %sectdone%==%copysec% &; if %leftsec%>=1 && set /A devfat1=%devfat1%+255 && set mdfat1=%mdbase% && goto :ddcopyloopfat32badclus ! goto :endofbadclustersfat32
set skip=0
set badinSC=0
if %secttodo%==%secpfat% && set /a leftlen=-%secpfat% + 1 * %bytepsec% + %fatsize% && set /a leftmax=-%secpfat% + 1 * %bytepsec% + %fatsize% && set /a maxbad=-%secpfat% + 1 * %bytepsec% + %fatsize% / 4
raw cat --skip=%skip% --locate=\x7F\xFF\xFF\xF0 --length=%leftlen% (md)%mdfat1%+1 > nul &; set /a badinSC=%@retval%
set /a sectdone=%sectdone%+1
if %badinSC%==0 &; if not %secttodo%>=%secpfat% && set /a secttodo=%secttodo%+1 && set /A mdfat1=%mdfat1%+1 && goto :badclustersfat32loop ! goto :endofbadclustersfat32
if %badinSC%==%maxbad% && set /a clusbad=%clusbad%+%maxbad% &; if not %secttodo%>=%secpfat% && set /a secttodo=%secttodo%+1 && set /A mdfat1=%mdfat1%+1 && goto :badclustersfat32loop ! goto :endofbadclustersfat32
:badclustersinsecfat32loop
raw cat --skip=%skip% --locate=\x7F\xFF\xFF\xF0 --length=%leftlen% --number=1 (md)%mdfat1%+1 | set nextbad= &; if exist nextbad && set /a nextbad=0x%nextbad%
if exist nextbad && calc %nextbad% % 4 && set /a leftlen=%leftmax%-%nextbad%-1 && set /a skip=%nextbad%+1
if exist nextbad && calc %nextbad% % 4 || set /a clusbad=%clusbad%+1 && set /a leftlen=%leftmax%-%nextbad%-4 && set /a skip=%nextbad%+4
if exist nextbad && set nextbad= && if %leftlen%>=4 && goto :badclustersinsecfat32loop
if not exist nextbad && if not %secttodo%>=%secpfat% && set /a secttodo=%secttodo%+1 && set /A mdfat1=%mdfat1%+1 && set leftlen=%bytepsec% && set leftmax=%bytepsec% && goto :badclustersfat32loop
:endofbadclustersfat32
if %test%==Y && call Fn.5 0 %v% ;; if %test%==Y && echo -n -e \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20%NULL% ;; if %test%==Y && call Fn.5 0 %v%
endlocal && set clusbad=%clusbad%
goto :eof
::
:getbadclustersfat12
if not %secpfat%<=12 &; if not %test%==Y && echo Abort %0 Sectors per FAT on FAT12: %secpfat%>12%NULL% ! set test=%test% &; goto :eof
setlocal
set /a fatsize=%numclus% * 3 &; calc %fatsize% % 2 ;; set /a fatsize=%fatsize%/2+%@retval%+3
echo -n > (md)%mdbase%+%secpfat%
if not exist FILE && raw dd if=%device%%%reserved%+%secpfat% of=(md)%mdbase%+%secpfat% bs=1 count=%fatsize% > nul
if exist FILE && set /A fileskip=%startsec% * 512 &; set /A fileskip=%reserved% * %bytepsec% + %fileskip% &; raw dd if=%FILE% of=(md)%mdbase%+%secpfat% bs=1 count=%fatsize% skip=%fileskip% > nul
#DEBUG#echo %0 numclus=%numclus% fatsize=%fatsize% secpfat=%secpfat% && cat --hex --skip=0x1500 --length=512 (md)%mdbase%+%secpfat% && pause
set clusbad=0
set address=3
#InsertWait...#
call Fn.4 ;; set /a v=%@retval%>>8 ;; call Fn.5 0 %v% ;; echo -n -e \x20$[0x0F]Counting bad clusters...%NULL%
:badclustersfat12loop
setlocal && set device=(md) && call :readdisk "%address%" "%mdbase%" "%secpfat%" &; endlocal && set result=%result% &; set /A evenclus=%result%&0xfff && set /A oddclus=%result%&0xffffff>>12
#DEBUG#if not %evenclus%==0xFF7 if not %oddclus%==0xFF7 || echo address=%address% evenclus=%evenclus% oddclus=%oddclus% clusbad=%clusbad% && pause
if %evenclus%==0xFF7 && set /a clusbad=%clusbad%+1
if %oddclus%==0xFF7 && set /a clusbad=%clusbad%+1
#DEBUG#if %evenclus%==0xFF7 && set /a clusbad=%clusbad%+1 && raw cat --hex --skip=%address% --length=16 (md)%mdbase%+%secpfat% && echo && pause Even: address=%address% Key...
#DEBUG#if %oddclus%==0xFF7 && set /a clusbad=%clusbad%+1 && raw cat --hex --skip=%address% --length=16 (md)%mdbase%+%secpfat% && echo && pause Odd: address=%address% key...
set /A address=%address%+3 &; if not %address%>=%fatsize% && set result= && set evenclus= && set oddclus= && goto :badclustersfat12loop
call Fn.5 0 %v% ;; echo -n -e \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20%NULL% ;; call Fn.5 0 %v%
endlocal && set clusbad=%clusbad%
goto :eof
::
:CHSLBAbalancetest
setlocal
if exist devstart && if exist start &; if %CDROM%==Y && set /a start=%devstart% * 4 + %start% ! set /a start=%devstart%+%start%
set /a HS=%numheads% * %sectrack% && set /a totsect=%devsect%+%hiddsect%
set /a tracks=%totsect%/%HS% &; if %numheads%<=2 && echo Number of tracks: %tracks%%%NULL% ! echo Number of cylinders: %tracks%%%NULL%
calc %totsect% % %HS% || echo CHS and LBA values are balanced%NULL% ! if not %sectrack%==63 && if not %numheads%==255 && echo $[0x0F]CHS and LBA values are NOT balanced%NULL% ! echo Unknown if CHS and LBA values are balanced%NULL%
if not %hiddsect%==0 &; if exist device && set /a ptstart=*0x82A8 ! if %CDROM%==Y && if exist start && set /a ptstart=%start% * 4 + %startsec% ! if exist start && set /a ptstart=%startsec%+%start% ! set ptstart=%startsec% &; calc %ptstart% % %sectrack% || echo Partition starts at begin of a head%NULL% ! if not %sectrack%==63 && if not %numheads%==255 && echo $[0x0F]Partition does not start at begin of a head%NULL% ! echo Unknown if partition starts at begin of a head%NULL%
if %hiddsect%==0 &; if exist device && set /a ptstart=*0x82A8 ! if %CDROM%==Y && if exist start && set /a ptstart=%start% * 4 + %startsec% ! if exist start && set /a ptstart=%startsec%+%start% ! set ptstart=%startsec% &; calc %ptstart% % %sectrack% || echo Volume starts at begin of a head%NULL% ! if not %sectrack%==63 && if not %numheads%==255 && echo $[0x0F]Volume does not start at begin of a head%NULL% ! echo Unknown if volume starts at begin of a head%NULL%
endlocal
goto :eof
::
:BS_signaturetest
setlocal
setlocal && call :readdisk "508" "0" "1" &; endlocal && set BSFStyp0=%result%
if %BSFStyp0:~0,6%==0xAA55 && echo Boot signature is valid (55AA)%NULL% ! echo $[0x0F]Boot signature is not valid (no 55AA)%NULL% && set result=0
if not /i %filesys%==fat32 && endlocal && set result=%result% && goto :eof
setlocal && call :readdisk "0" "%FSinfosc%" "1" &; endlocal && set FSleadsg=%result%
if %FSleadsg%==0x41615252 && echo Lead signature on FSinfo sector is valid (RRaA)%NULL% ! echo $[0x0F]Lead signature on FSinfo sector is not valid (no RRaA)%NULL% && set result=0
setlocal && call :readdisk "484" "%FSinfosc%" "1" &; endlocal && set FSstrcsg=%result%
if %FSstrcsg%==0x61417272 && echo Structure signature on FSinfo sector is valid (rrAa)%NULL% ! echo $[0x0F]Structure signature on FSinfo sector is not valid (no rrAa)%NULL% && set result=0
setlocal && call :readdisk "508" "%FSinfosc%" "1" &; endlocal && set BSFStyp1=%result%
if %BSFStyp1%==0xAA550000 && echo Trail signature on FSinfo sector is valid (000055AA)%NULL% ! echo $[0x0F]Trail signature on FSinfo sector is not valid (no 000055AA)%NULL% && set result=0
set /a bootsec2=%FSinfosc%+1 &; call Fn.11 "%bootcode%" "Windows" && set /a bootsec2=%FSinfosc%+11 ! call Fn.11 "%bootcode%" "REACTOS" && set /a bootsec2=%FSinfosc%+13
setlocal && call :readdisk "508" "%bootsec2%" "1" &; endlocal && set BSFStyp2=%result%
if %BSFStyp2%==0xAA550000 && echo Trail signature on last bootsector is valid (000055AA)%NULL% ! echo $[0x0F]Trail signature on last bootsector is not valid (no 000055AA)%NULL% && set result=0
endlocal && set result=%result%
goto :eof
::
:BPB_totalsectortest
setlocal
if not %test%==Y &; set /a needsect=%numfats% * %secpfat% + %reserved% + %startsec% &; if not %devsect%<=%needsect% && set devsect=%needsect%
#BuggyIfBootedFromCD#set rootorg=%@root%
if exist @uefi &; if not %device:~1,2%==rd && set rootOK=Y && rootnoverify %device% > nul
if not exist @uefi && if not %CDROM%==Y && set rootOK=Y && rootnoverify %device% > nul
if %hiddsect%==0 &; if %rootOK%==Y &; set /a ptstart=*0x82A8 &; if not %ptstart%==%hiddsect% && if not exist RD && echo $[0x0F]Number of hidden sectors before is not correct%NULL% && set result=0 ! if not exist RD && echo Number of hidden sectors before is correct%NULL% ! if %ptstart%==%hiddsect% && echo Number of hidden sectors before is correct%NULL% ! echo No test of number of hidden sectors before%NULL%
if %device:~-3,1%==, && set partitio=%device:~-2,1% ! if %device:~-4,1%==, && set partitio=%device:~-3,2%
if not %partitio%>=4 && if not %hiddsect%==0 &; if %rootOK%==Y &; set /a ptstart=*0x82A8 &; if not %ptstart%==%hiddsect% && if not exist RD && echo $[0x0F]Number of hidden sectors before is not correct%NULL% && set result=0 ! if not exist RD && echo Number of hidden sectors before is correct%NULL% ! if exist partitio && if %ptstart%==%hiddsect% && echo Number of hidden sectors before is correct%NULL% ! echo No test of number of hidden sectors before%NULL%
if %partitio%>=4 && if not %hiddsect%==0 &; if %rootOK%==Y &; set /a ptstart=*0x82A8 &; if not %ptstart%==%hiddsect% && if not exist RD && echo Number of hidden sectors before start of logical partition is not equal%NULL% ! if not exist RD && echo Number of hidden sectors before is correct%NULL% ! echo No test of number of hidden sectors before%NULL%
if %hiddsect%==0 && if %device:~1,2%==rd &; set /a rdsect=*0x82D8/%bytepsec%&0xffffffff ! set rdsect=%sectors% &; if not %rdsect%>=%devsect% && echo $[0x0F]Total number of sectors exceeds number of sectors on volume%NULL% && set result=0 ! echo Total number of sectors fits on volume%NULL% && set totsecOK=Y
#BadNow#if %hiddsect%==0 && if %device:~1,2%==rd &; set /a rdsect=*0x82D8/%bytepsec%&0xffffffff ! set rdsect=%sectors% &; if not %rdsect%>=%devsect% && echo $[0x0F]Total number of sectors exceeds number of sectors on volume%NULL% && endlocal && set rdsect=%rdsect% && set result=0 && goto :eof ! echo Total number of sectors fits on volume%NULL% && endlocal && set rdsect=%rdsect% && set result=%result% && set totsecOK=Y && goto :eof
if %test%==Y && if not %hiddsect%==0 && if %device:~1,2%==rd &; set /a rdsect=*0x82D8/%bytepsec%&0xffffffff ! set rdsect=%sectors% &; if not %rdsect%>=%devsect% && echo $[0x0F]Total number of sectors exceeds number of sectors on partition%NULL% ! echo Total number of sectors fits on partition%NULL%
#BadNow#if %test%==Y && if not %hiddsect%==0 && if %device:~1,2%==rd &; set /a rdsect=*0x82D8/%bytepsec%&0xffffffff ! set rdsect=%sectors% &; if not %rdsect%>=%devsect% && echo $[0x0F]Total number of sectors exceeds number of sectors on partition%NULL% && endlocal && set rdsect=%rdsect% && set result=0 && goto :eof ! echo Total number of sectors fits on partition%NULL% && endlocal && set rdsect=%rdsect% && set result=%result% && goto :eof
if %hiddsect%==0 &; if not %test%==Y && if %device:~1,2%==rd &; set /a rdsect=*0x82D8/%bytepsec%&0xffffffff ! set rdsect=%sectors% &; if not %rdsect%>=%devsect% && set result=0
#BadNow#if %hiddsect%==0 &; if not %test%==Y && if %device:~1,2%==rd &; set /a rdsect=*0x82D8/%bytepsec%&0xffffffff ! set rdsect=%sectors% &; if not %rdsect%>=%devsect% && endlocal && set result=0 && goto :eof ! endlocal && goto :eof
if not %partitio%>=4 && if not %hiddsect%==0 && if %rootOK%==Y && if %device:~1,2%==rd &; set /a ptlength=*0x82B0 ! set rdsect=%sectors% &; if not %ptlength%>=%devsect% && echo $[0x0F]Total number of sectors exceeds number of sectors on volume%NULL% && set result=0 ! echo Total number of sectors fits on volume%NULL%
if %rootOK%==Y &; root %rootorg% > nul
set /a testsec=%devsect%-1
blocklist %device%%%testsec%+1 > nul
set /a devlenOK=%@retval%
if %hiddsect%==0 &; if %devlenOK%==0 && set result=0 && echo $[0x0F]Last sector on volume is NOT valid%NULL% ! echo Last sector on volume is valid%NULL% && set totsecOK=Y
if not %hiddsect%==0 &; if %devlenOK%==0 && set result=0 && echo $[0x0F]Last sector on partition is NOT valid%NULL% ! echo Last sector on partition is valid%NULL% && set totsecOK=Y
if not %totsecOK%==Y && set /a needsect=%numfats% * %secpfat% + %reserved% + %hiddsect% &; if not %devsect%>=%needsect% if not %ptlength%>=%needsect% if not %rdsect%>=%needsect% |; set totsecOK=Y
endlocal && set result=%result% && set totsecOK=%totsecOK% && set rdsect=%rdsect%
goto :eof
::
:BPB_imagesectortest
setlocal
if not exist start && set start=0
if not %test%==Y &; set /a needsect=%numfats% * %secpfat% + %reserved% + %startsec% &; if not %devsect%<=%needsect% && set devsect=%needsect%
if not %FILE:~0,3%==(rd && if not %CDROM%==Y && raw cat --length=0 %FILE% && set /A filelen=*0x8290 &; set /A checklen=-%bytepsec% * %startsec% + %filelen%
if not %FILE:~0,3%==(rd && if not %CDROM%==Y && raw cat --length=0 %FILE% && set /A filelen=*0x8290 &; set /A checklen=-%bytepsec% * %startsec% + %filelen%
if not %FILE:~0,3%==(rd && if %CDROM%==Y &; if exist CDtotsec && set /A filelen=%CDtotsec% * 2k ! set /A filelen=%sectors% * 2k &; set /A checklen=-%bytepsec% * %startsec% + %filelen%
if %FILE:~0,3%==(rd &; if not %disk%==Y && set /A filelen=*0x82D8 ! set /A filelen=%sectors% * 512 &; set /A checklen=-%bytepsec% * %startsec% + %filelen%
if %FILE:~0,3%==(rd &; if %disk%==Y &; raw cat --length=0 %FILE% && set /A filelen=*0x8290 &; set /A checklen=-%bytepsec% * %startsec% + %filelen%
#TooMuch?#if %hiddsect%==0 &; set /a ptstart=%startsec% &; if not %ptstart%==%hiddsect% && if not %disk%==Y && if not /i %EXT%==.iso && echo $[0x0F]Number of hidden sectors before start of volume is not correct%NULL% && set result=0 ! if not /i %EXT%==.iso && echo Number of hidden sectors before start of volume is correct%NULL% ! echo No test of number of hidden sectors before start of volume%NULL%
if %hiddsect%==0 &; set /a ptstart=%startsec% &; if not %ptstart%==%hiddsect% && if not %disk%==Y && if not /i %EXT%==.iso && echo $[0x0F]Number of hidden sectors before is not correct%NULL% && set result=0 ! echo Number of hidden sectors before is correct%NULL%
#NEWforBlocklistOnPartition#
if %disk%==Y && if not %devstart%>=1 &; call Fn.11 "%FILE%" "," &; rootnoverify %FILE% > nul && set /a ptstart=*0x82A8&0xffffffff ! set ptstart= &; root %rootorg% > nul
if %disk%==Y && if %devstart%>=1 && set /a ptstart=%startsec%+%devstart%
#BAD#if %disk%==Y &; call Fn.11 "%FILE%" "," &; rootnoverify %FILE% > nul && set /a ptstart=*0x82A8&0xffffffff ! set ptstart= &; root %rootorg% > nul
#DEBUG#echo %0 block=%block% devstart=%devstart% disk=%disk% RD=%RD% rootOK=%rootOK% hiddsect=%hiddsect% startsec=%startsec% start=%start% ptstart=%ptstart%
if not %partitio%>=4 && if not %hiddsect%==0 &; if not exist ptstart && set /a ptstart=%startsec%+%start% ! set ptstart=%ptstart% &; if not %ptstart%==%hiddsect% && if not %disk%==Y && echo $[0x0F]Number of hidden sectors before is not correct%NULL% && set result=0 ! if %ptstart%==%hiddsect% && if %block%==Y && echo Number of hidden sectors before is correct%NULL% ! if not %ptstart%>=%hiddsect% && if %disk%==Y && echo $[0x0F]Number of hidden sectors before is not correct%NULL% ! if %disk%==Y && echo Number of hidden sectors before is not equal%NULL% ! echo Number of hidden sectors before is correct%NULL%
#Too Strict#if not %partitio%>=4 && if not %hiddsect%==0 &; if not exist ptstart && set /a ptstart=%startsec%+%start% ! set ptstart=%ptstart% &; if not %ptstart%==%hiddsect% && if not %disk%==Y && echo $[0x0F]Number of hidden sectors before start of partition is not correct%NULL% && set result=0 ! if not %ptstart%>=%hiddsect% && if %disk%==Y && echo $[0x0F]Number of hidden sectors before start of partition is not correct%NULL% && set result=0 ! echo Number of hidden sectors before start of partition is correct%NULL%
if %partitio%>=4 && if not %hiddsect%==0 &; if not %hiddsect%==%hiddsectL% && echo $[0x0F]Number of hidden sectors before start of logical partition is not correct%NULL% && set result=0 ! echo Number of hidden sectors before start of logical partition is correct%NULL%
#BAD#if not %hiddsect%==0 &; if not exist ptstart && set /a ptstart=%startsec%+%start% ! set ptstart=%ptstart% &; if not %ptstart%==%hiddsect% && if not %disk%==Y && if not %partitio%>=4 && echo $[0x0F]Number of hidden sectors before start of partition is not correct%NULL% && set result=0 ! if not %ptstart%>=%hiddsect% && if %disk%==Y && echo $[0x0F]Number of hidden sectors before start of partition is not correct%NULL% && set result=0 ! if not %ptstart%==%hiddsect% && if %partitio%>=4 && echo Number of hidden sectors before start of logical partition is not equal%NULL% ! if not %partitio%>=4 && echo Number of hidden sectors before start of partition is correct%NULL%
#BAD#if not %hiddsect%==0 &; if not exist ptstart && set /a ptstart=%startsec% ! set ptstart=%ptstart% &; if not %ptstart%==%hiddsect% && if not %disk%==Y && echo $[0x0F]Number of hidden sectors before start of partition is not correct%NULL% && set result=0 ! if not %ptstart%>=%hiddsect% && if %disk%==Y && echo $[0x0F]Number of hidden sectors before start of partition is not correct%NULL% && set result=0 ! echo Number of hidden sectors before start of partition is correct%NULL%
#DEBUG#pause B ptstart=%ptstart%
if %hiddsect%==0 &; set /a devbyte=%devsect% * %bytepsec% &; if not %checklen%>=%devbyte% && if not %disk%==Y && echo $[0x0F]Total number of sectors exceeds number of sectors on volume%NULL% && set result=0 ! if not %checklen%>=%devbyte% && if %disk%==Y && echo $[0x0F]Total number of sectors exceeds number of sectors in blocklist%NULL% && set result=0 ! echo Total number of sectors fits on volume%NULL% && set totsecOK=Y
if not %hiddsect%==0 &; set /a devbyte=%devsect% * %bytepsec% &; if not %checklen%>=%devbyte% && if not %disk%==Y && echo $[0x0F]Total number of sectors exceeds number of sectors on partition%NULL% && set result=0 ! if not %checklen%>=%devbyte% && if %disk%==Y && echo $[0x0F]Total number of sectors exceeds number of sectors in blocklist%NULL% && set result=0 ! echo Total number of sectors fits on partition%NULL% && set totsecOK=Y
if not %totsec%==Y && set /a needlen=%numfats% * %secpfat% + %reserved% + %hiddsect% * %bytepsec% &; if %checklen%>=%needlen% &; set totsecOK=Y
endlocal && set result=%result% && set totsecOK=%totsecOK%
goto :eof
::
:fat32backuptest
setlocal
if exist FILE && set /a needbyte=%hiddsect% + %backsect% + 2 * %bytepsec% &; if not %filesize%>=%needbyte% &; echo $[0x0F]Test of backup of bootsectors starting at sector %backsect%: not possible%NULL% && endlocal && set result=0 && goto :eof
if not exist FILE && set /a needsect=%backsect%+2 &; if not %devsect%>=%needsect% && echo $[0x0F]Test of backup of bootsectors starting at sector %backsect%: not possible%NULL% && endlocal && set result=0 && goto :eof
#ToTest#if exist FILE && set /A mdbase2=%mdbase%+1 && set /A backskip=%startsec% * 512 &; set startbyt=%backskip% && set /A backskip=%backsect% * 512 + %backskip% &; raw dd if=%FILE% of=(md)%mdbase%+1 bs=1 count=512 skip=%startbyt% > nul && raw dd if=%FILE% of=(md)%mdbase2%+1 bs=1 count=512 skip=%backskip% > nul
if exist FILE && set /A mdbase2=%mdbase%+1 && set /A backskip=%startsec% * 512 &; set startbyt=%backskip% && set /A backskip=%backsect% * %bytepsec% + %backskip% &; raw dd if=%FILE% of=(md)%mdbase%+1 bs=1 count=%bytepsec% skip=%startbyt% > nul && raw dd if=%FILE% of=(md)%mdbase2%+1 bs=1 count=%bytepsec% skip=%backskip% > nul
if %device:~0,3%==(rd && set /A mdbase2=%mdbase%+1 &; raw dd if=%device%%0+1 of=(md)%mdbase%+1 > nul && raw dd if=%device%%%backsect%+1 of=(md)%mdbase2%+1 > nul
if not exist FILE && if not %device:~0,3%==(rd && cmp %device%%0+1 %device%%%backsect%+1 > nul ! cmp (md)%mdbase%+1 (md)%mdbase2%+1 > nul
if %@retval%==0 && set result=0 ! set OK=1
set /a bootsec2=%backsect%+1
#ToTest#if exist FILE && set /A mdbase2=%mdbase%+2 && set /a fileskip=%startsec% * 512 &; set /a backskip=%bootsec2% * 512 + %fileskip% && set /a fileskip=%FSinfosc% * 512 + %fileskip% && set /a countbyt=2 * 512 &; raw dd if=%FILE% of=(md)%mdbase%+2 bs=1 count=%countbyt% skip=%fileskip% > nul && raw dd if=%FILE% of=(md)%mdbase2%+2 bs=1 count=%countbyt% skip=%backskip% > nul
#ORG#
if exist FILE && set /A mdbase2=%mdbase%+2 && set /a fileskip=%startsec% * 512 &; set /a backskip=%bootsec2% * %bytepsec% + %fileskip% && set /a fileskip=%FSinfosc% * %bytepsec% + %fileskip% && set /a countbyt=2 * %bytepsec% &; raw dd if=%FILE% of=(md)%mdbase%+2 bs=1 count=%countbyt% skip=%fileskip% > nul && raw dd if=%FILE% of=(md)%mdbase2%+2 bs=1 count=%countbyt% skip=%backskip% > nul
if not exist FILE && set /A mdbase2=%mdbase%+2 &; raw dd if=%device%%%FSinfosc%+2 of=(md)%mdbase%+2 > nul && raw dd if=%device%%%bootsec2%+2 of=(md)%mdbase2%+2 > nul
cmp --skip=0x200 (md)%mdbase%+2 (md)%mdbase2%+2
if %@retval%==0 && set result=0 ! if %OK%==1 && set OK=2
cmp (md)%mdbase%+1,0x1E8 (md)%mdbase2%+1,0x1E8 > nul
if %@retval%==0 && set result=0 ! if %OK%==2 && set OK=3
cmp --skip=0x1F0 (md)%mdbase%+1 (md)%mdbase2%+1 > nul
if %@retval%==0 && set result=0 ! if %OK%==3 && set OK=4
if not %OK%==4 && echo $[0x0F]Backup of bootsectors starting at sector %backsect% is not valid%NULL% ! echo Backup of bootsectors starting at sector %backsect% is valid%NULL%
endlocal && set result=%result%
goto :eof
::
:checkmediabyte
setlocal
if not %mediabyt%==0xF0 &; checkrange 0xF8:0xFF calc %mediabyt% || endlocal && echo $[0x0F]Media descriptor %mediabyt% is out of range 0xF8:0xFF%NULL% && set result=0 && goto :eof
if %mediabyt%==0xFC && if not %numheads%==1 && if not %sectrack%==9 && if not %bytepsec%==512 && if not %numfats%==2 && set badmedia=Y
if %mediabyt%==0xFD && if not %numheads%==2 && if not %sectrack%==9 && if not %bytepsec%==512 && if not %numfats%==2 && set badmedia=Y
if %mediabyt%==0xFE && if not %numheads%==1 && if not %sectrack%==8 && if not %bytepsec%==512 && if not %numfats%==2 && set badmedia=Y
if %mediabyt%==0xFF && if not %numheads%==2 && if not %sectrack%==8 && if not %bytepsec%==512 && if not %numfats%==2 && set badmedia=Y
if %mediabyt%==0xF9 &; if not %numheads%==2 && set badmedia=Y ! set badmedia= &; if not %sectrack%==9 if not %sectrack%==15 && set badmedia=Y
if %mediabyt%==0xF9 && if not %badmedia%==Y && if %sectrack%==9 && if not %bytepsec%==512 && if not %numfats%==2 && set badmedia=Y
if %mediabyt%==0xF9 && if not %badmedia%==Y && if %sectrack%==15 && if not %bytepsec%==512 && if not %numfats%==2 && set badmedia=Y
if %badmedia%==Y && echo $[0x0F]Media descriptor %mediabyt% is not valid%NULL% && set result=0
if not %badmedia%==Y && echo Media descriptor %mediabyt% is valid%NULL%
if not %totsecOK%==Y && endlocal && set result=0 && goto :eof
setlocal && call :readdisk "0" "%reserved%" "1" &; set /A mediafat=%result%&0xff &; endlocal && set mediafat=%mediafat%
if %mediafat%==%mediabyt% && set mediaoke=Y ! set mediaoke=N && set result=0
if not exist FILE && if not %test%==Y &; if %mediaoke%==N && echo $[0x0F]Media descriptor %mediabyt% is not same as start of FAT1%NULL% && echo Start of FAT1%NULL% && cat --hex --length=16 %device%%%reserved%+1%NULL% && set /a startFT2=%reserved%+%secpfat% &; echo Start of FAT2%NULL% && cat --hex --length=16 %device%%%startFT2%+1%NULL%
if exist FILE && if not %test%==Y &; if %mediaoke%==N && echo $[0x0F]Media descriptor %mediabyt% is not same as start of FAT1%NULL% && echo Start of FAT1%NULL% &; set /A fileskip=%startsec% + %reserved% * %bytepsec% &; cat --hex --skip=%fileskip% --length=16 %FILE%%%NULL% && set /a fileskip=%startsec% + %reserved% + %secpfat% * %bytepsec% &; echo Start of FAT2%NULL% && cat --hex --skip=%fileskip% --length=16 %FILE%%%NULL%
endlocal && set mediaoke=%mediaoke% && set result=%result%
goto :eof
::
:getshutdownflag
setlocal
if exist FILE && if %disk%==Y && set /a lesssect=%hiddsect%+%reserved% &; if %devsect%<=%lesssect% && echo $[0x0F]Test of shutdownflag in start of FAT1: not possible%NULL% && endlocal && set result=0 && goto :eof
if exist FILE && if not %disk%==Y && set /a rsrvbyte=%hiddsect% + %reserved% * %bytepsec% &; if %filesize%<=%rsrvbyte% && echo $[0x0F]Test of shutdownflag in start of FAT1: not possible%NULL% && endlocal && set result=0 && goto :eof
#DEBUG#if /i %filesys%==fat16 && setlocal && call :readdisk "2" "%reserved%" "1" &; echo %0 result=%result% && endlocal && set shutdown=0x%result:~6,2% &; echo shutdown=%shutdown%
#DEBUG#if /i %filesys%==fat32 && setlocal && call :readdisk "4" "%reserved%" "1" &; echo %0 result=%result% && endlocal && set shutdown=%result:~0,4% &; echo shutdown=%shutdown%
if /i %filesys%==fat16 && setlocal && call :readdisk "2" "%reserved%" "1" &; endlocal && set shutdown=0x%result:~6,2%
if /i %filesys%==fat32 && setlocal && call :readdisk "4" "%reserved%" "1" &; endlocal && set shutdown=%result:~0,4%
if /i %filesys%==fat16 &; if %shutdown%==0xFF && echo Shutdown flag: %shutdown% (clean)%NULL% ! if %shutdown%==0x7F && set result=0 && echo $[0x0F]Shutdown flag: %shutdown% (dirty)%NULL% ! if %shutdown%==0xBF && set result=0 && echo $[0x0F]Shutdown flag: %shutdown%(disk I/O error)%NULL% ! echo %NULL%
if /i %filesys%==fat32 &; if %shutdown%==0xFF && echo Shutdown flag: %shutdown% (clean)%NULL% ! if %shutdown%==0x0F && echo Shutdown flag: %shutdown% (clean)%NULL% ! if %shutdown%==0xF7 && set result=0 && echo $[0x0F]Shutdown flag: %shutdown% (dirty)%NULL% ! if %shutdown%==0x07 && set result=0 && echo $[0x0F]Shutdown flag: %shutdown% (dirty)%NULL% ! if %shutdown%==0xFB && set result=0 && echo $[0x0F]Shutdown flag: %shutdown%(disk I/O error)%NULL% ! if %shutdown%==0x0B && set result=0 && echo $[0x0F]Shutdown flag: %shutdown% (disk I/O error)%NULL% ! echo %NULL%
#BAD#if /i %filesys%==fat32 &; if %shutdown%==0xFF && echo Shutdown flag: %shutdown% (clean)%NULL% ! if %shutdown%==0x0F && echo Shutdown flag: %shutdown% (clean) ! if %shutdown%==0xF7 && set result=0 && echo $[0x0F]Shutdown flag: %shutdown% (dirty)%NULL% ! if %shutdown%==0x07 && set result=0 && echo $[0x0F]Shutdown flag: %shutdown% (dirty)%NULL% ! if %shutdown%==0xFB && set result=0 && echo $[0x0F]Shutdown flag: %shutdown%(disk I/O error)%NULL% ! if %shutdown%==0x0B && set result=0 && echo $[0x0F]Shutdown flag: %shutdown% (disk I/O error)%NULL% ! echo %NULL%
endlocal && set shutdown=%shutdown% && set result=%result%
goto :eof
::
:checkfatstart
setlocal
if exist FILE && if %disk%==Y &; set /a lesssect=%hiddsect%+%reserved% &; if %devsect%<=%lesssect% && echo $[0x0F]Test of start of FAT1: not possible%NULL% && endlocal && set result=0 && goto :eof
if exist FILE && if not %disk%==Y && set /a rsrvbyte=%hiddsect% + %reserved% * %bytepsec% &; if %filesize%<=%rsrvbyte% && echo $[0x0F]Test of start of FAT1: not possible%NULL% && endlocal && set result=0 && goto :eof
#DEBUG#if /i %filesys%==fat12 &; setlocal && call :readdisk "0" "%reserved%" "1" &; echo %0 result=%result% && endlocal && set /A clus01=%result%&0xffffff &; set clus01=000000%clus01:~2% &; set clus01=0x%clus01:~-6,6% &; if %clus01:~0,-2%==0xFFFF%mediabyt% && set fatoke=Y ! set result=0
if /i %filesys%==fat12 &; setlocal && call :readdisk "0" "%reserved%" "1" &; endlocal && set clus01=0x%result:~-6,6% &; if %clus01%==0xFFFF%mediabyt:~2% && set fatoke=Y ! set result=0
if /i %filesys%==fat16 &; setlocal && call :readdisk "0" "%reserved%" "1" &; endlocal && set clus01=0x%result:~-8,8% &; if %clus01%==0x%shutdown:~2%%FFFF%mediabyt:~2% && set fatoke=Y ! set result=0
if /i %filesys%==fat32 &; setlocal && call :readdisk "0" "%reserved%" "1" &; endlocal && set clus0=%result% &; setlocal && call :readdisk "4" "%reserved%" "1" &; endlocal && set clus1=%result% &; if %clus0%==0xFFFFFF%mediabyt:~2% && if %clus1%==0x%shutdown:~2%FFFFFF && set fatoke=Y ! if %clus0%==0x0FFFFF%mediabyt:~2% && if %clus1%==0x%shutdown:~2%FFFFFF && set fatoke=Y ! set result=0
if /i %filesys%==fat12 &; if %fatoke%==Y && echo Start of FAT1 is valid, media descriptor is start of FAT%NULL% ! echo $[0x0F]Start of FAT1 is not valid: %clus01% (%clus01:~-2,2%%%clus01:~-4,2%%%clus01:~-6,2%)%NULL%
if /i %filesys%==fat16 &; if %fatoke%==Y && echo Start of FAT1 is valid, media descriptor is start of FAT%NULL% ! echo $[0x0F]Start of FAT1 is not valid: %clus01% (%clus01:~-2,2%%%clus01:~-4,2%%%clus01:~-6,2%%%clus01:~-8,2%)%NULL%
if /i %filesys%==fat32 &; if %fatoke%==Y && echo Start of FAT1 is valid, media descriptor is start of FAT%NULL% ! echo $[0x0F]Start of FAT1 is not valid: %clus1%%%clus0:~2% (%clus0:~-2,2%%%clus0:~-4,2%%%clus0:~-6,2%%%clus0:~-8,2%%%clus1:~-2,2%%%clus1:~-4,2%%%clus1:~-6,2%%%clus1:~-8,2%)%NULL%
endlocal && set result=%result%
goto :eof
::
:comparefat1fat2
setlocal
#NotGood#if not %totsecOK%==Y && set /a needsect=%numfats% * %secpfat% + %reserved% + %startsec% &; if %devsect%>=%needsect% && set totsecOK=Y
if not %totsecOK%==Y && echo $[0x0F]Comparison of FAT1 and FAT2: not possible%NULL% && endlocal && set result=0 && goto :eof
#NONEED#if /i %filesys%==fat12 && set /a fatsize=%numclus% * 3 &; calc %fatsize% % 2 #BAD#;; if /i %filesys%==fat12 && set /a fatsize=%fatsize%/2+%@retval%+3
if /i %filesys%==fat12 && set /a fatsize=%numclus% * 3 &; calc %fatsize% % 2 ;; set /a fatsize=%fatsize%/2+%@retval%+3
if /i %filesys%==fat16 && set /a fatsize=%numclus% * 2 + 4
if /i %filesys%==fat32 && set /a fatsize=%numclus% * 4 + 8
if not exist FILE && set devfat1=%reserved% && set /a devfat2=%reserved%+%secpfat%
if exist FILE && set /a fat1sec=%startsec%+%reserved% && set /a fat2sec=%startsec%+%reserved%+%secpfat% && set /a fatsect=%fatsize%/%bytepsec% &; calc %fatsize% % %bytepsec% && set /a fatsec=%fatsec%+1 ! set fatsec=%fatsec% &; if not %secpfat%<=255 && set testsec=255 && set /a leftsec=%fatsect%-255 ! set testsec=%fatsect% && set leftsec=0 &; set /A mdbase2=%mdbase%+%testsec%
:comparefat1fat2loop
if exist FILE && echo -n > (md)%mdbase%+%testsec% && echo -n > (md)%mdbase2%+%testsec%
if exist FILE && raw dd if=%FILE% of=(md)%mdbase%+%testsec% count=%testsec% skip=%fat1sec% > nul
if exist FILE && raw dd if=%FILE% of=(md)%mdbase2%+%testsec% count=%testsec% skip=%fat2sec% > nul
if not exist FILE &; cmp %device%%%devfat1%+%secpfat%,%fatsize% %device%%%devfat2%+%secpfat%,%fatsize% > nul && set f12equal=Y ! set f12equal=N
if exist FILE &; cmp (md)%mdbase%+%testsec% (md)%mdbase2%+%testsec% > nul && set f12equal=Y ! set f12equal=N &; if %f12equal%==Y && if %leftsec%>=1 &; if %leftsec%>=255 && set /a fat1sec=%fat1sec%+255 && set /a fat2sec=%fat2sec%+255 && set /a leftsec=%leftsec%-255 ! set /a fat1sec=%fat1sec%+%leftsec% && set /a fat2sec=%fat2sec%+%leftsec% && set leftsec=0 &; goto :comparefat1fat2loop
if %f12equal%==Y && echo Comparison of FAT1 and FAT2: equal%NULL% ! echo $[0x0F]Comparison of FAT1 and FAT2: NOT equal%NULL% && set result=0
endlocal && set f12equal=%f12equal% && set result=%result%
goto :eof
::
:hexview
setlocal
#BAD#if exist FILE && set /A skip=%startsec% * %bytepsec% + %offset% && set /A skip3=%startsec% + %reserved% * %bytepsec% + %offset% && set /A skip4=%startsec% + %reserved% + %secpfat% * %bytepsec% + %offset%
if exist FILE && set /A skip=%startsec% * %bytepsec% && set /A skip3=%startsec% + %reserved% * %bytepsec% && set /A skip4=%startsec% + %reserved% + %secpfat% * %bytepsec%
echo Sector 0 &; if not exist FILE && cat --hex --length=0x200 %device%%0+1 ! cat --hex --skip=%skip% --length=0x200 %FILE%
if /i %filesys%==fat32 && if exist FILE && set /A skip1=%startsec% + 1 * %bytepsec% && set /A skip2=%startsec% + 2 * %bytepsec% &; call Fn.11 "%bootcode%" "Windows" && set sector=12 && set /A skip5=%startsec% + 12 * %bytepsec% ! call Fn.11 "%bootcode%" "REACTOS" && set sector=14 && set /A skip5=%startsec% + 14 * %bytepsec%
#BAD???#if /i %filesys%==fat32 && if exist FILE && set /A skip1=%startsec% + 1 * %bytepsec% && set /A skip2=%startsec% + 1 * %bytepsec% &; call Fn.11 "%bootcode%" "Windows" && set sector=12 && set /A skip5=%startsec% + 12 * %bytepsec% #! call Fn.11 "%bootcode%" "REACTOS" && set sector=14 && set /A skip5=%startsec% + 14 * %bytepsec%
if /i %filesys%==fat32 &; if not exist FILE && echo Sector 1 && cat --hex --skip=0x200 --length=0x200 %device%%0+3 && echo Sector 2 && cat --hex --skip=0x400 --length=0x200 %device%%0+3 && if exist skip5 && echo Sector %sector% && cat --hex --length=0x200 %device%%%sector%+1
if /i %filesys%==fat32 &; if exist FILE && echo Sector 1 && cat --hex --skip=%skip1% --length=0x200 %FILE% && echo Sector 2 && cat --hex --skip=%skip2% --length=0x200 %FILE% && if exist skip5 && echo Sector %sector% && cat --hex --skip=%skip5% --length=0x200 %FILE%
if not exist FILE && set /A skipfat1=%startsec% + %reserved% * %bytepsec% && set /A skipfat2=%startsec% + %reserved% + %secpfat% * %bytepsec% &; if %numfats%==1 && set /a sectors=%startsec% + %reserved% + %secpfat% ! set /a sectors=%startsec% + %reserved% + %secpfat% + %secpfat%
if %numfats%>=1 &; if not exist FILE && echo Start of FAT1 && cat --hex --skip=%skipfat1% --length=0x200 %device%%0+%sectors% && if %numfats%>=2 && echo Start of FAT2 && cat --hex --skip=%skipfat2% --length=0x200 %device%%0+%sectors% ! echo Start of FAT1 && cat --hex --skip=%skip3% --length=0x200 %FILE% && if %numfats%>=2 && echo Start of FAT2 && cat --hex --skip=%skip4% --length=0x200 %FILE%
if /i %filesys%==fat32 && if not exist FILE && set /a sectors=%sectors%+1 &; echo Start of ROOT && cat --hex --skip=%dataarea% --length=0x200 %device%%0+%sectors%
if /i %filesys%==fat32 && if exist FILE && set /a skip4=%numfats% * %secpfat% * %bytepsec% + %skip3% &; echo Start of ROOT && cat --hex --skip=%skip4% --length=0x200 %FILE%
if not /i %filesys%==fat32 && if not exist FILE && set /a sectors=%sectors%+1 &; echo Start of ROOT && cat --hex --skip=%root% --length=0x200 %device%%0+%sectors%
if not /i %filesys%==fat32 && if exist FILE && set /a skip4=%numfats% * %secpfat% * %bytepsec% + %skip3% &; echo Start of ROOT && cat --hex --skip=%skip4% --length=0x200 %FILE%
endlocal
goto :eof
::
:checksecpfat
setlocal
if /i %filesys%==fat12 && set /a FATsec=%numclus% * 3 + 1 / 2 + 3 &; calc %FATsec% % 512 || set /a FATsec=%FATsec%>>9 ! set /a FATsec=%FATsec%>>9+1 &; if not %FATsec%<=%secpfat% && echo -n $[0x0F]Number of Sectors per FAT is not valid%NULL% && set result=0 ! echo -n Number of sectors per FAT is valid%NULL%
#ORG#if /i %filesys%==fat12 && set /a FATsec=%numclus% * 3 / 2 + 3 &; calc %FATsec% % 512 || set /a FATsec=%FATsec%>>9 ! set /a FATsec=%FATsec%>>9+1 &; if not %FATsec%<=%secpfat% && echo -n $[0x0F]Number of Sectors per FAT is not valid%NULL% && set result=0 ! echo -n Number of sectors per FAT is valid%NULL%
if /i %filesys%==fat16 && set /a FATsec=%numclus% * 2 + 4 &; calc %FATsec% % 512 || set /a FATsec=%FATsec%>>9 ! set /a FATsec=%FATsec%>>9+1 &; if not %FATsec%<=%secpfat% && echo -n $[0x0F]Number of Sectors per FAT is not valid%NULL% && set result=0 ! echo -n Number of sectors per FAT is valid%NULL%
if /i %filesys%==fat32 && set /a FATsec=%numclus% * 4 + 8 &; calc %FATsec% % 512 || set /a FATsec=%FATsec%>>9 ! set /a FATsec=%FATsec%>>9+1 &; if not %FATsec%<=%secpfat% && echo -n $[0x0F]Number of Sectors per FAT is not valid%NULL% && set result=0 ! echo -n Number of sectors per FAT is valid%NULL%
set /a fatspace=%secpfat% * %bytepsec%
if /i %filesys%==fat12 && set /a fatsize=%numclus% * 3 &; calc %fatsize% % 2 ;; set /a fatsize=%fatsize%/2+%@retval%+3
if /i %filesys%==fat16 && set /a fatsize=%numclus% * 2 + 4
if /i %filesys%==fat32 && set /a fatsize=%numclus% * 4 + 8
set /a roomleft=%bytepsec% * %secpfat% - %fatsize%
if %roomleft%>=%bytepsec% && set /a unusedSC=%roomleft%/%bytepsec% &; echo $[], unused sector(s) in FAT: %unusedSC%%%NULL%
if not %roomleft%>=%bytepsec% && echo $[], no unused sector(s) in FAT%NULL%
endlocal && set unusedSC=%unusedSC% && set result=%result%
goto :eof
::
#BEFOREv0.8#:filesystem
#-# check if filesystem is FAT12/16/32
setlocal && set * && set mdbase=%mdbase%
set device=%~1
echo -n > (md)%mdbase%+1
errorcheck off
debug msg=1
if exist device && vol %device% > (md)%mdbase%+1
debug msg=0
cat --locate=\x0A --number=1 (md)%mdbase%+1 > nul &; set /a skip=%?%
if exist device && if exist skip && set filesys=fat12 &; cat --skip=%skip% --locate=%filesys% (md)%mdbase%+1 > nul |; set filesys=fat16 &; cat --skip=%skip% --locate=%filesys% (md)%mdbase%+1 > nul |; set filesys=fat32 &; cat --skip=%skip% --locate=%filesys% (md)%mdbase%+1 > nul |; set filesys=initrdfs &; cat --skip=%skip% --locatei=%filesys% (md)%mdbase%+1 > nul |; set filesys=
#BADifVOLNAMEcontainsFATxx#if exist device && set filesys=fat12 &; cat --locatei=%filesys% (md)%mdbase%+1 > nul |; set filesys=fat16 &; cat --locatei=%filesys% (md)%mdbase%+1 > nul |; set filesys=fat32 &; cat --locatei=%filesys% (md)%mdbase%+1 > nul |; set filesys=initrdfs &; cat --locatei=%filesys% (md)%mdbase%+1 > nul |; set filesys=
pause %0 filesys=%filesys%
endlocal && set filesys=%filesys%
goto :eof
::
:bootblockbase
#-# read-out bootsector as far as needed
#NotGood#setlocal && set * && set mdbase=%mdbase% && set filesys=%filesys% && set device=%device% && set "FILE=%FILE%" && set startsec=%startsec% && set skipbyte=%skipbyte%
setlocal && set * && set mdbase=%mdbase% && set filesys=%filesys% && set device=%device% && set "FILE=%FILE%" && set startsec=%startsec% && set "NULL=%NULL%"
echo -n > (md)%mdbase%+1
if %~1==device && raw dd if=%device%%0+1 of=(md)%mdbase%+1 > nul
#NotGood#if %~1==FILE &; if exist skipbyte && set /a skip=%skipbyte% ! set /a skip=%startsec% * 512 &; raw dd if=%FILE% of=(md)%mdbase%+1 bs=1 count=512 skip=%skip% > nul
#BAD#if %~1==FILE && set /a skip=%startsec% * 512 + %offset% &; raw dd if=%FILE% of=(md)%mdbase%+1 bs=1 count=512 skip=%skip% > nul
#DEBUG#echo %0 %^~1=%~1 && set && pause && echo
if %~1==FILE && set /a skip=%startsec% * 512 &; raw dd if=%FILE% of=(md)%mdbase%+1 bs=1 count=512 skip=%skip% > nul
#DEBUG#cat --hex --skip=%skip% --length=512 %FILE% && pause && echo
#DEBUG#cat --hex (md)%mdbase%+1 && pause && echo
set /A base=%mdbase% * 0x200
set /A address=%base%
read %address% > nul ;; set /A jmpBoot=%@retval%&0xffffff ;; set jmpBoot=000000%jmpBoot:~2% ;; set jmpBoot=0x%jmpBoot:~-6,6%
set /A address=%base%+0x3
cat --skip=3 --length=8 (md)%mdbase%+1 | set OEMName=
set /A address=%base%+0xB
#NEW#
read %address% > nul ;; set /a bytepsec=%@retval%&0xffff
#In:fatintegritytest# &; if %bytepsec%==0 && endlocal && echo Abort: Bytes per Sector is zero, not a fat-device && set result=0 && goto :eof
#In:fatintegritytest#calc %bytepsec% % 32 &;  && endlocal && echo Abort: Unsupported, Bytes per Sector is not a multiple of 32 && set result=0 && goto :eof
#NormalCase#calc %bytepsec% % 512 &;  && endlocal && echo Abort: Unsupported, Bytes per Sector is not a multiple of 512 && set result=0 && goto :eof
set /A address=%base%+0xD
read %address% > nul ;; set /a secpclus=%@retval%&0xff
#In:fatintegritytest# &; if %secpclus%==0 && endlocal && echo Abort: no valid fat-device, Sectors per Cluster is zero && set result=0 && goto :eof
#In:fatintegritytest#if %secpclus%>=2 && calc %secpclus% % 2 &; endlocal && echo Abort: no valid fat-device, Sectors per Cluster is not a multiple of 2 (above 2) && set result=0 && goto :eof
set /A address=%base%+0xE
read %address% > nul ;; set /a reserved=%@retval%&0xffff
#In:fatintegritytest# &; if %reserved%==0 && endlocal && echo Abort: no valid fat-device, Reserved Sectors are zero && set result=0 && goto :eof
set /A address=%base%+0x10
read %address% > nul ;; set /a numfats=%@retval%&0xff
#In:fatintegritytest# &; if not %numfats%>=1 && endlocal && echo Abort: number of fat's is zero && set result=0 && goto :eof ! if %numfats%>=3 && endlocal && echo Abort: %numfats% File Allocation Tables unsupported && set result=0 && goto :eof
set /A address=%base%+0x11
read %address% > nul ;; set /a rootentr=%@retval%&0xffff
#NotHere &; calc %rootentr% % 16 &; set /a rootentr=%rootentr%+1
#TooStrict:Grubutil'fat'Only#read %address% > nul #ORG#;; set /a rootentr=%@retval%&0xffff &; calc %rootentr% % 16 &; if %~1==device && endlocal && echo %rootentr% Root entries on %device% not supported%NULL% && set result=0 && goto :eof ! if %~1==FILE && endlocal && echo %rootentr% Root entries on %FILE% not supported%NULL% && set result=0 && goto :eof ! endlocal && set result=0 && goto :eof
set /a rootsect=%rootentr% * 32 / %bytepsec% &; calc %rootentr% % 16 &; set /a rootsect=%rootsect%+1
set /A address=%base%+0x13
read %address% > nul ;; set /a totsect=%@retval%&0xffff
#In:fatintegritytest#if %totsect%==0 && if %bytepsec%==32 && endlocal && echo Abort: Bytes per Sector is 32, not valid with zero Total number of Sectors (below 32MB) && set result=0 && goto :eof
set /A address=%base%+0x15
read %address% > nul ;; set /A mediabyt=%@retval%&0xff
#In:fatintegritytest# &; if %mediabyt%==0 && endlocal && echo Abort: no valid fat-device, Media Byte is zero && set result=0 && goto :eof
set /A address=%base%+0x16
read %address% > nul ;; set /a secpfat=%@retval%&0xffff
set /a fatsect=%numfats% * %secpfat%
set /A address=%base%+0x18
read %address% > nul ;; set /a sectrack=%@retval%&0xffff
#In:fatintegritytest=Reserved# &; if %sectrack%==0 && endlocal && echo Abort: no valid fat-device, Sectors per Track are zero && set result=0 && goto :eof ! if not %sectrack%<=63 && endlocal && echo Abort: no valid fat-device, Sectors per Track out of range && set result=0 && goto :eof
set /A address=%base%+0x1A
read %address% > nul ;; set /a numheads=%@retval%&0xffff
#In:fatintegritytest=Reserved# &; if %numheads%==0 && endlocal && echo Abort: no valid fat-device, Number of Heads are zero && set result=0 && goto :eof ! if not %numheads%<=255 && endlocal && echo Abort: no valid fat-device, Number of Heads out of range && set result=0 && goto :eof
## Special check of Hidden Sectors on FAT < Version 4.0!
if not %secpfat%==0 && set /A address=%base%+0x26 &; set extbtsig=0 && read %address% > nul &; set /A extbtsig=%@retval%&0xff
set /A address=%base%+0x1C
#ForBetterCompatibilityWithBPB<4.0#
read %address% > nul ;; if not %extbtsig%==0x28 if not %extbtsig%==0x29 || set /a hiddsect=%@retval%&0xffffffff ! set /a hiddsect=%@retval%&0xffff
#CheckHereForValidTotalSectors#
if %totsect%==0 && set /A address=%base%+0x20
if %totsect%==0 && read %address% > nul ;; if %totsect%==0 && set /a totsect=%@retval%&0xffffffff
#ORG#if %totsect%==0 && read %address% > nul &; set /a totsect=%@retval%&0xffffffff
## TEST here, not in :fatintegritytest is OK
if %totsect%==0 && echo Abort: no valid fat-device, Total number of Sectors is zero%NULL% && set result=0 && goto :eof
if %secpfat%==0 && set /A address=%base%+0x24
if %secpfat%==0 && read %address% > nul &; if %secpfat%==0 && set /a secpfat=%@retval%&0xffffffff
## TEST here, not in :fatintegritytest is OK
if %secpfat%==0 && echo Abort: no valid fat-device, Sectors per FAT is zero%NULL% && set result=0 && goto :eof
set /a checkclus=%totsect%-%reserved%-%rootsect%-%fatsect%/%secpclus% &; if %checkclus%<=4084 && set filesys=fat12 ! if %checkclus%<=65524 && set filesys=fat16 ! if %checkclus%<=0xFFFFFF6 && set filesys=fat32 ! endlocal && set result=0 && goto :eof
#BAD#if not %totsect%==0 && if %~1==FILE && set /a checkclus=%totsect%/%secpclus% &; if %checkclus%<=4084 && set filesys=fat12 ! if %checkclus%<=65524 && set filesys=fat16 ! if %checkclus%<=0xFFFFFFFF && set filesys=fat32 ! endlocal && set result=0 && goto :eof
if not /i %filesys%==fat32 && set /A address=%base%+0x24 && set BSdrvnum=0x0 &; read %address% > nul &; set /A BSdrvnum=%@retval%&0xff
#BAD=16bits#if %secpfat%==0 && if /i %filesys%==fat32 && read %address% > nul &; set /a secpfat=%@retval%&0xffff
if not /i %filesys%==fat32 && set /A address=%base%+0x25 && set reserve1=0 &; read %address% > nul &; set /a reserve1=%@retval%&0xff
#EARLIER#if not /i %filesys%==fat32 && set /A address=%base%+0x26 &; set extbtsig=0 && read %address% > nul &; set /A extbtsig=%@retval%&0xff
if not /i %filesys%==fat32 && set /A address=%base%+0x27 &; read %address% &; set /A uuidh=%@retval%&0xffffffff &; set uuid=00000000%uuidh:~2% &; set uuid=%uuid:~-8,4%-%uuid:~-4,4%
## only if extbtsig=0x29
if not /i %filesys%==fat32 && if %extbtsig%==0x29 &; cat --skip=0x2B --length=11 (md)%mdbase%+1 | set bootvol=
if /i %filesys%==fat32 && set /A address=%base%+0x2C &; read %address% > nul &; set /a ROOTclus=%@retval%&0xffffffff
if /i %filesys%==fat32 && set /A address=%base%+0x30 &; read %address% > nul &; set /a FSinfosc=%@retval%&0xffff
if /i %filesys%==fat32 && set /A address=%base%+0x32 &; read %address% > nul &; set /a backsect=%@retval%&0xffff
if /i %filesys%==fat32 && set /A address=%base%+0x40 && set BSdrvnum=0x0 &; read %address% > nul &; set /A BSdrvnum=%@retval%&0xff
if /i %filesys%==fat32 && set /A address=%base%+0x41 && set reserve1=0 &; read %address% > nul &; set /a reserve1=%@retval%&0xff
if /i %filesys%==fat32 && set /A address=%base%+0x42 &; set extbtsig=0 && read %address% > nul &; set /A extbtsig=%@retval%&0xff
if /i %filesys%==fat32 && set /A address=%base%+0x43 &; read %address% &; set /A uuidh=%@retval%&0xffffffff &; set uuid=00000000%uuidh:~2% &; set uuid=%uuid:~-8,4%-%uuid:~-4,4%
if /i %filesys%==fat32 && cat --skip=0x47 --length=11 (md)%mdbase%+1 | set bootvol=
set /A rootbyte=%rootentr% * 32
set /a fatsect=%numfats% * %secpfat%
set /a fatbyte=%fatsect% * %bytepsec%
set /A rsrvbyte=%reserved% * %bytepsec%
if not /i %filesys%==fat32 && set /A root=%fatbyte% + %rsrvbyte%
set /A dataarea=%rootbyte% + %fatbyte% + %rsrvbyte%
set /a clussize=%secpclus% * %bytepsec%
set /A fat1=%rsrvbyte%
if /i %filesys%==fat32 && set /a numclus=%totsect%-%fatsect%-%reserved%/%secpclus%
if /i %filesys%==fat16 && set /a numclus=%totsect% * %bytepsec% - %rootbyte% - %fatbyte% - %rsrvbyte% / %clussize%
if /i %filesys%==fat12 && set /a numclus=%totsect% * %bytepsec% - %rootbyte% - %fatbyte% - %rsrvbyte% / %clussize%
endlocal && set dataarea=%dataarea% && set clussize=%clussize% && set numclus=%numclus% && set root=%root% && set fat1=%fat1% && set hiddsect=%hiddsect% && set devsect=%totsect% && set secpclus=%secpclus% && set mediabyt=%mediabyt% && set reserved=%reserved% && set secpfat=%secpfat% && set bytepsec=%bytepsec% && set numfats=%numfats% && set rootentr=%rootentr% && set uuid=%uuid% && set secpclus=%secpclus% && set backsect=%backsect% && set ROOTclus=%ROOTclus% && set FSinfosc=%FSinfosc% && set BSdrvnum=%BSdrvnum% && set jmpBoot=%jmpBoot% && set reserve1=%reserve1% && set filesys=%filesys% && set sectrack=%sectrack% && set numheads=%numheads% && set extbtsig=%extbtsig% && set "OEMName=%OEMName%" && set "bootvol=%bootvol%"
goto :eof
::
:checkfatsubtype
#-# MS: numclus on FAT12 <4085; on FAT16 <65525 (FAT32 max 0xFFFFFFFD clusters)
if %numclus%<=1 && set filesys= && goto :eof
if %numclus%<=4084 && set filesysT=fat12 && goto :eof
if %numclus%<=65524 && set filesysT=fat16 && goto :eof
if %numclus%>=65525 && if %numclus%<=0xFFFFFFFD && set filesysT=fat32 ! set filesys=
goto :eof
::
:FSinfo
#-# FSinfo Sector: unknown number of free clusters: 0x3E8=0xFFFFFFFF; unknown next free cluster: 0x3EC=0xFFFFFFFF; Remark: next_free is using last allocated cluster, first free clusnum = +1
#-# FSI-LeadSig (offset 0/0x0 size 4): 0x41615252 (= RRaA). This is a lead signature used to validate that this is in fact an FSInfo sector.
#-# FSI-Reserved1 (offset 4/0x4 size 480): Reserved. This field should be always initialized to zero.
#-# FSI-StrucSig (offset 484/0x3E4 size 4): 0x61417272 (= rrAa). Another signature that is more localized in the sector to the location of the fields that are used.
#-# FSI-Free_Count (offset 488/0x3E8 size 4): This field indicates the last known free cluster count on the volume. If the value is 0xFFFFFFFF, it is actually unknown. This is not necessarily correct, so that the FAT driver needs to make sure it is valid for the volume.
#-# FSI-Nxt_Free (offset 492/0x3EC size 4): This field gives a hint for the FAT driver, the cluster number at which the driver should start looking for free clusters. Because a FAT32 FAT is large, it can be rather time consuming if there are a lot of allocated clusters at the start of the FAT and the driver starts looking for a free cluster starting at the first cluster. Typically this value is set to the last cluster number that the driver allocated. If the value is 0xFFFFFFFF, there is no hint and the driver should start looking at cluster 2. This may not be correct, so that the FAT driver needs to make sure it is valid for the volume.
#-# FSI-Reserved2 (offset 496/0x3F0 size 12): Reserved. This field should be always initialized to zero.
#-# FSI_TrailSig (offset 508/0x3FC size 4): 0xAA550000. This trail signature is used to validate that this is in fact an FSInfo sector (most sources say 0xAA55 only)
setlocal && set * && set device=%device% && set devsect=%devsect% && set bytepsec=%bytepsec% && set FSinfosc=%FSinfosc% && set "FILE=%FILE%" && set startsec=%startsec% && set bytepsec=%bytepsec%
call :readdisk "0x1E8" "%FSinfosc%" "1" &; if  exist result && set /a clusfree=%result% && set result= ! set clusfree=0xFFFFFFFF
call :readdisk "0x1EC" "%FSinfosc%" "1" &; if  exist result && set /a nextfree=%result% && set result= ! set nextfree=0xFFFFFFFF
endlocal && set clusfrFS=%clusfree% && set nextfrFS=%nextfree%
goto :eof
::
:getbootcode
## Both FAT bootcodes identical for VISTA && Win7!!
setlocal && set * && set mdbase=%mdbase% && set device=%device% && set "FILE=%FILE%" && set startsec=%startsec% && set start=%start% && set jmpBoot=%jmpBoot% && set filesys=%filesys% && set bytepsec=%bytepsec% && set "OEMName=%OEMName%"
if not exist start && set start=0
echo -n > (md)%mdbase%+1
if not exist FILE && raw dd if=%device%%0+1 of=(md)%mdbase%+1
#BAD#if exist FILE && set /A skip=%startsec% + %start% * %bytepsec% + %offset% &; raw dd if=%FILE% of=(md)%mdbase%+1 bs=1 count=%bytepsec% skip=%skip%
if exist FILE && set /A skip=%startsec% + %start% * %bytepsec% &; raw dd if=%FILE% of=(md)%mdbase%+1 bs=1 count=512 skip=%skip%
if not /i %filesys%==FAT32 &; raw cat --skip=62 --locate=\x00 (md)%mdbase%+1 > nul &; if %@retval%>=448 && endlocal && set bootcode=Empty && goto :eof
if /i %filesys%==FAT32 &; raw cat --skip=90 --locate=\x00 (md)%mdbase%+1 > nul &; if %@retval%>=420 && endlocal && set bootcode=Empty && goto :eof
set /A mdbase2=%mdbase%+1 && if /i %filesys%==FAT32 && set /A mdbase3=%mdbase%+2 && set /A mdbase4=%mdbase%+3
if /i %filesys%==FAT32 && set codenum=20 && goto :FAT32bootcode ! set codenum=0
:FATbootcode
if %codenum%>=11 &; cat --locate="IBMBIO  COM" (md)%mdbase%+1 > nul && set bootcode=IBMBIO.COM ! cat --locate="IO      SYS" (md)%mdbase%+1 > nul && set bootcode=IO.SYS ! cat --locate="NTLDR      " (md)%mdbase%+1 > nul && set bootcode=NTLDR ! cat --locate="BOOTMGR    " (md)%mdbase%+1 > nul && set bootcode=BOOTMGR ! cat --locate="KERNEL  SYS" (md)%mdbase%+1 > nul && set bootcode=KERNEL.SYS ! cat --locate="FREELDR SYS" (md)%mdbase%+1 > nul && set bootcode=FREELDR.SYS ! cat --locate="GRLDR      " (md)%mdbase%+1 > nul && set bootcode=GRLDR ! set bootcode=Unknown &; endlocal && set bootcode=%bootcode% && goto :eof
echo -n > (md)%mdbase2%+1 && set S1= && set L1= && set S2= && set L2=
if %codenum%==0 &; set "bootcode=MS-DOS 3.3" && set S1=0x3E && set L1=0x148 && set S2=0x1E0 && set L2=0x16 && set BCCRC32=0x274bbacc
if %codenum%==1 &; set "bootcode=MS-DOS 4.0" && set S1=0x3E && set L1=0x154 && set S2=0x1DB && set L2=0x16 && set BCCRC32=0x95cc9901
if %codenum%==2 &; set "bootcode=MS-DOS 5.0" && set S1=0x3E && set L1=0x15F && set S2=0x1E6 && set L2=0x16 && set BCCRC32=0xd851c138
#BADforWINBOOT.SYS#
if %codenum%==3 &; if "%OEMName%"=="MSWIN4.0" && set "bootcode=MS-DOS 7.0" ! set "bootcode=MS-DOS 7.1" &; set S1=0x3E && set L1=0x145 && set S2=0x1D8 && set L2=0x16 && set BCCRC32=0xe4c441fc
if %codenum%==4 &; set "bootcode=Windows 2k/XP" && set S1=0x3E && set L1=0x16e && set S2=0x1F4 && set L2=0x8 && set BCCRC32=0x210066e2
if %codenum%==5 &; set "bootcode=Windows Vista" && set S1=0x3E && set L1=0x163 && set S2=0x1F8 && set L2=0x6 && set BCCRC32=0xbd0879fd
if %codenum%==6 &; set "bootcode=Windows 10" && set S1=0x3E && set L1=0x163 && set S2=0x1F8 && set L2=0x6 && set BCCRC32=0xca1e465b
if %codenum%==7 &; set bootcode=FREEDOS && set S1=0x3E && set L1=0x1BE && set S2= && set L2= && set BCCRC32=0x5ccc5adf
if %codenum%==8 &; set bootcode=REACTOS && set S1=0x3E && set L1=0x18C && set S2=0x1E6 && set L2=0xB && set BCCRC32=0x3eb26dce
if %codenum%==9 &; set bootcode=GRUB && set S1=0x3E && set L1=0x152 && set S2=0x1e3 && set L2=0xB && set BCCRC32=0x31076756
if %codenum%==10 &; if "%OEMName%"=="MSWIN4.0" && set "bootcode=MS-DOS 7.0 (WINBOOT.SYS)" ! set "bootcode=MS-DOS 7.1 (WINBOOT.SYS)" &; set S1=0x3E && set L1=0x146 && set S2=0x1D8 && set L2=0x24 && set BCCRC32=0x99ea4ecf
#NOTNOW#if %codenum%==11 &; set "bootcode=MS-DOS 7 (OSR2 DELL)" &; set S1=0x3E && set L1=0x185 && set S2=0x1D8 && set L2=0x1FC && set BCCRC32=0x
#FORNEXTONE#if %codenum%== &; set bootcode= && set S1= && set L1= && set S2= && set L2= && set BCCRC32=0x
#DEBUG#if not %codenum%==3 if not %codenum%==10 if not %codenum%==11 || pause bootcode=%bootcode% S1=%S1% L1=%L1%
if not exist FILE &; raw dd if=%device%%0+1 of=(md)%mdbase2%+1 bs=1 count=%L1% skip=%S1% seek=%S1%
if not exist FILE && if exist S2 && if exist L2 &; raw dd if=%device%%0+1 of=(md)%mdbase2%+1 bs=1 count=%L2% skip=%S2% seek=%S2%
if exist FILE && set /A skip1=%skip%+%S1% &; raw dd if=%FILE% of=(md)%mdbase2%+1 bs=1 count=%L1% skip=%skip1% seek=%S1%
if exist FILE && if exist S2 && if exist L2 && set /A skip1=%skip%+%S2% &; raw dd if=%FILE% of=(md)%mdbase2%+1 bs=1 count=%L2% skip=%skip1% seek=%S2%
crc32 (md)%mdbase2%+1 > nul ;; set /A CRC32=%@retval%&0xffffffff
#DEBUG#pause codenum=%codenum% CRC32A=%CRC32A%
#DEBUG#if %codenum%== &; endlocal && set "bootcode=%bootcode%" && goto :eof
if not %CRC32%==%BCCRC32% && set bootcode= && set /a codenum=%codenum%+1 && goto :FATbootcode
endlocal && set "bootcode=%bootcode%"
goto :eof
:FAT32bootcode
if %codenum%>=28 &; cat --locate="IBMBIO  COM" (md)%mdbase%+1 > nul && set bootcode=IBMBIO.COM ! cat --locate="IO      SYS" (md)%mdbase%+1 > nul && set bootcode=IO.SYS ! cat --locate="NTLDR      " (md)%mdbase%+1 > nul && set bootcode=NTLDR ! cat --locate="BOOTMGR    " (md)%mdbase%+1 > nul && set bootcode=BOOTMGR ! cat --locate="KERNEL  SYS" (md)%mdbase%+1 > nul && set bootcode=KERNEL.SYS ! cat --locate="FREELDR SYS" (md)%mdbase%+1 > nul && set bootcode=FREELDR.SYS ! cat --locate="GRLDR      " (md)%mdbase%+1 > nul && set bootcode=GRLDR ! set bootcode=Unknown &; endlocal && set bootcode=%bootcode% && goto :eof
echo -n > (md)%mdbase2%+1 && echo -n > (md)%mdbase4%+1 && set S1= && set L1= && set S2= && set L2= && set S3= && set L3= && set sect= && set skip1= && set skip3=
if %codenum%==20 &; set "bootcode=MS-DOS 7.1" && set S1=0x5A && set L1=0x128 && set S2=0x1D8 && set L2=0x28 && set S3=0 && set L3=0x186 && set sect=2 && set /A skip3=%skip%+0x400 && set BCCRC32A=0xb36d57ea && set BCCRC32B=0x8d519e27
if %codenum%==21 &; set "bootcode=Windows 2k/XP" && set S1=0x5A && set L1=0x152 && set S2=0x1e8 && set L2=0x18 && set S3=0 && set L3=0x147 && set sect=12 && set /A skip3=%skip%+0x1800 && set BCCRC32A=0xe706909b && set BCCRC32B=0x25669c6d
if %codenum%==22 &; set "bootcode=Windows Vista" && set S1=0x5A && set L1=0x10F && set S2=0x169 && set L2=0x7 && set S3=0 && set L3=0x147 && set sect=12 && set /A skip3=%skip%+0x1800 && set BCCRC32A=0xc0a3e404 && set BCCRC32B=0x695f28dd
#Windows 7 EQUAL to VISTA#
if %codenum%==23 && set /a codenum=%codenum%+1
#UNUSEDNOW#if %codenum%==23 &; set "bootcode=Windows 7" && set S1=0x5A && set L1=0x106 && set S2=0x1ea && set L2=0x16 && set S3=0 && set L3=0x147 && set sect=12 && set /A skip3=%skip%+0x1800 && set BCCRC32A=0x5d0e683d && set BCCRC32B=0x695f28dd
if %codenum%==24 &; set "bootcode=Windows 10" && set S1=0x5A && set L1=0x121 && set S2=0x1F8 && set L2=0x4 && set S3=0x6E && set L3=0x157 && set sect=12 && set /A skip3=%skip%+0x1800 && set BCCRC32A=0x2dad97bb && set BCCRC32B=0x5aed1930
if %codenum%==25 &; set bootcode=FREEDOS && set S1=0x5A && set L1=0x167 && set S2=0x1F1 && set L2=0xB && set BCCRC32A=0xc4f4353d
if %codenum%==26 &; set bootcode=REACTOS && set S1=0x5A && set L1=0x159 && set S2=0x1F3 && set L2=0x9 && set S3=0 && set L3=0x185 && set sect=14 && set /A skip3=%skip%+0x1C00 && set BCCRC32A=0x8f1952b5 && set BCCRC32B=0x04d6a62c
if %codenum%==27 &; set bootcode=GRUB && set S1=0x5A && set L1=0x153 && set S2= && set L2= && set BCCRC32A=0x5ad79713
#FORNEXTONE#if %codenum%== &; set bootcode= && set S1=0x5A && set L1= && set S2= && set L2= && set S3= && set L3= && set sect= && set /A skip3=%skip%+ && set BCCRC32A=0x && set BCCRC32B=0x
if not exist FILE &; raw dd if=%device%%0+1 of=(md)%mdbase2%+1 bs=1 count=%L1% skip=%S1% seek=%S1%
if not exist FILE && if exist S2 && if exist L2 &; raw dd if=%device%%0+1 of=(md)%mdbase2%+1 bs=1 count=%L2% skip=%S2% seek=%S2%
if exist FILE && set /A skip1=%skip%+%S1% &; raw dd if=%FILE% of=(md)%mdbase2%+1 bs=1 count=%L1% skip=%skip1% seek=%S1%
if exist FILE && if exist S2 && if exist L2 && set /A skip1=%skip%+%S2% &; raw dd if=%FILE% of=(md)%mdbase2%+1 bs=1 count=%L2% skip=%skip1% seek=%S2%
crc32 (md)%mdbase2%+1 > nul ;; set /A CRC32A=%@retval%&0xffffffff
#DEBUG#pause codenum=%codenum% CRC32A=%CRC32A%
#DEBUG#if %codenum%== &; cat --hex (md)%mdbase%+1 && pause
#DEBUG#if %codenum%== &; endlocal && set "bootcode=%bootcode%" && goto :eof
if not %CRC32A%==%BCCRC32A% && set bootcode= && set /a codenum=%codenum%+1 && goto :FAT32bootcode
#IfBootCodeIsOnlyOneSector#
if not %codenum%==25 if not %codenum%==27 |; endlocal && set "bootcode=%bootcode%" && goto :eof
if not exist FILE && raw dd if=%device%%%sect%+1 of=(md)%mdbase4%+1 bs=1 count=%L3% skip=%S3% seek=%S3%
if exist FILE && set /A skip3=%skip3%+%S3% &; raw dd if=%FILE% of=(md)%mdbase4%+1 bs=1 count=%L3% skip=%skip3% seek=%S3%
crc32 (md)%mdbase4%+1 > nul ;; set /A CRC32B=%@retval%&0xffffffff
#DEBUG#pause CRC32B=%CRC32B%
#DEBUG#if %codenum%== &; cat --hex (md)%mdbase4%+1 && pause
if not %CRC32B%==%BCCRC32B% && set bootcode= && set /a codenum=%codenum%+1 && goto :FAT32bootcode
endlocal && set "bootcode=%bootcode%"
goto :eof
::
:readdisk
setlocal && set * && set device=%device% && set devsect=%devsect% && set "FILE=%FILE%" && set startsec=%startsec% && set bytepsec=%bytepsec%
if not "%~2"=="" && set /a start=%~2 ! set start=0
if not "%~3"=="" && set /a devsect=%~3
#DEBUG#echo %0 "if exist FILE &; if %device%==(md) && set FILE= ! set /A fileskip=%startsec% + %start% * %bytepsec% + %~1
if exist FILE &; if %device%==(md) && set FILE= ! set /A fileskip=%startsec% + %start% * %bytepsec% + %~1
if exist fileskip && set skip=%fileskip% ! set /A skip=%~1 &; set /a s=%@retval%
#DEBUG#echo %0 "if not exist FILE && raw cat --hex --skip=%skip% --length=4 %device%%%start%+%devsect% | set LE= &; if %s%<=10 && set "LE=%LE:~10,11%" ! call set "LE=%^LE:~%s%,11%" &; if "%LE:~0,1%"==" " && set "LE=%LE:~1%"
if not exist FILE && raw cat --hex --skip=%skip% --length=4 %device%%%start%+%devsect% | set LE= &; if %s%<=10 && set "LE=%LE:~10,11%" ! call set "LE=%^LE:~%s%,11%" &; if "%LE:~0,1%"==" " && set "LE=%LE:~1%"
#DEBUG#echo %0 "if exist FILE && raw cat --hex --skip=%skip% --length=4 %FILE% | set LE= &; if %s%<=10 && set "LE=%LE:~10,11%" ! call set "LE=%^LE:~%s%,11%" &; if "%LE:~0,1%"==" " && set "LE=%LE:~1%"
if exist FILE && raw cat --hex --skip=%skip% --length=4 %FILE% | set LE= &; if %s%<=10 && set "LE=%LE:~10,11%" ! call set "LE=%^LE:~%s%,11%" &; if "%LE:~0,1%"==" " && set "LE=%LE:~1%"
if not "%LE:~9,1%"==" " && set result=0x%LE:~9,2%%%LE:~6,2%%%LE:~3,2%%%LE:~0,2% ! if not "%LE:~6,1%"==" " && set result=0x%LE:~6,2%%%LE:~3,2%%%LE:~0,2% ! if not "%LE:~3,1%"==" " && set result=0x%LE:~3,2%%%LE:~0,2% ! if not "%LE:~0,1%"==" " && set result=0x%LE:~0,2%
endlocal && set result=%result%
goto :eof
::
:Fn.5
call Fn.5 %~1 %~2
goto :eof
::
:findstartsector
setlocal
set bytepsec=512
set startsec=0 && set startext=0 && set lognum=3
#BAD#if %partitio%>=4 && set /a partitio=%partitio%+1
:logicalpartitionloop
if %lognum%>=63 && endlocal && set result=0 && goto :eof
#NONEED#set /a devsect=%startsec%+1
call :readdisk "510" &; if not %result:~-4,4%==AA55 && endlocal && set result=0 && goto :eof
#DEBUG#echo MAGIC=%result%
call :readdisk "0x1C2" &; set partid0=0x%result:~-2,2% &; if %partitio%==0 &; if not %partid0%==0 && if not %partid0%==0x1 && if not %partid0%==0x11 && if not %partid0%==0x4 && if not %partid0%==0x14 && if not %partid0%==0x5 && if not %partid0%==0x15 && if not %partid0%==0x6 && if not %partid0%==0x16 && if not %partid0%==0xB && if not %partid0%==0x1B && if not %partid0%==0xE && if not %partid0%==0x1E && if not %partid0%==0xC && if not %partid0%==0x1C && if not %partid0%==0xF && if not %partid0%==0x1F && endlocal && set result=0 && goto :eof
call :readdisk "0x1D2" &; set partid1=0x%result:~-2,2% &; if %partitio%==1 &; if not %partid1%==0 && if not %partid1%==0x1 && if not %partid1%==0x11 && if not %partid1%==0x4 && if not %partid1%==0x14 && if not %partid1%==0x5 && if not %partid1%==0x15 && if not %partid1%==0x6 && if not %partid1%==0x16 && if not %partid1%==0xB && if not %partid1%==0x1B && if not %partid1%==0xE && if not %partid1%==0x1E && if not %partid1%==0xC && if not %partid1%==0x1C && if not %partid1%==0xF && if not %partid1%==0x1F && endlocal && set result=0 && goto :eof
call :readdisk "0x1E2" &; set partid2=0x%result:~-2,2% &; if %partitio%==2 &; if not %partid2%==0 && if not %partid2%==0x1 && if not %partid2%==0x11 && if not %partid2%==0x4 && if not %partid2%==0x14 && if not %partid2%==0x5 && if not %partid2%==0x15 && if not %partid2%==0x6 && if not %partid2%==0x16 && if not %partid2%==0xB && if not %partid2%==0x1B && if not %partid2%==0xE && if not %partid2%==0x1E && if not %partid2%==0xC && if not %partid2%==0x1C && if not %partid2%==0xF && if not %partid2%==0x1F && endlocal && set result=0 && goto :eof
call :readdisk "0x1F2" &; set partid3=0x%result:~-2,2% &; if %partitio%==3 &; if not %partid3%==0 && if not %partid3%==0x1 && if not %partid3%==0x11 && if not %partid3%==0x4 && if not %partid3%==0x14 && if not %partid3%==0x5 && if not %partid3%==0x15 && if not %partid3%==0x6 && if not %partid3%==0x16 && if not %partid3%==0xB && if not %partid3%==0x1B && if not %partid3%==0xE && if not %partid3%==0x1E && if not %partid3%==0xC && if not %partid3%==0x1C && if not %partid3%==0xF && if not %partid3%==0x1F && endlocal && set result=0 && goto :eof
call :readdisk "0x1C6" &; set /a startsc0=%result% &; if %partitio%==0 &; if not %startsc0%>=1 && endlocal && set result=0 && goto :eof ! if not %partid0%==0x5 && if not %partid0%==0xF && if not %partid0%==0x15 && if not %partid0%==0x1F && endlocal && set result=%startsc0% && goto :eof
call :readdisk "0x1D6" &; set /a startsc1=%result% &; if %partitio%==1 &; if not %startsc1%>=1 && endlocal && set result=0 && goto :eof ! if not %partid1%==0x5 && if not %partid1%==0xF && if not %partid1%==0x15 && if not %partid1%==0x1F && endlocal && set result=%startsc1% && goto :eof
call :readdisk "0x1E6" &; set /a startsc2=%result% &; if %partitio%==2 &; if not %startsc2%>=1 && endlocal && set result=0 && goto :eof ! if not %partid2%==0x5 && if not %partid2%==0xF && if not %partid2%==0x15 && if not %partid2%==0x1F && endlocal && set result=%startsc2% && goto :eof
call :readdisk "0x1F6" &; set /a startsc3=%result% &; if %partitio%==3 &; if not %startsc3%>=1 && endlocal && set result=0 && goto :eof ! if not %partid3%==0x5 && if not %partid3%==0xF && if not %partid3%==0x15 && if not %partid3%==0x1F && endlocal && set result=%startsc3% && goto :eof
#DEBUG#echo partid0=%partid0% startsc0=%startsc0%
#DEBUG#echo partid1=%partid1% startsc1=%startsc1%
#DEBUG#echo partid2=%partid2% startsc2=%startsc2%
#DEBUG#echo partid3=%partid3% startsc3=%startsc3%
#DEBUG#echo %0 B partitio=%partitio% lognum=%lognum% startsec=%startsec% startext=%startext% && pause
if %partitio%<=3 && endlocal && set result=0 && goto :eof
if %partitio%==%lognum% && if not %startsec%==0 &; if not %partid0%==0x1 if not %partid0%==0x11 if not %partid0%==0x4 if not %partid0%==0x14 if not %partid0%==0x6 if not %partid0%==0x16 if not %partid0%==0xB if not %partid0%==0x1B if not %partid0%==0xE if not %partid0%==0x1E if not %partid0%==0xC if not %partid0%==0x1C |; if not %startsc0%>=1 && endlocal && set result=0 && goto :eof ! endlocal && set result=%startsec%+%startsc0% && set hiddsecL=%startsc0% && goto :eof
if %partitio%==%lognum% && if not %startsec%==0 &; if not %partid1%==0x1 if not %partid1%==0x11 if not %partid1%==0x4 if not %partid1%==0x14 if not %partid1%==0x6 if not %partid1%==0x16 if not %partid1%==0xB if not %partid1%==0x1B if not %partid1%==0xE if not %partid1%==0x1E if not %partid1%==0xC if not %partid1%==0x1C |; if not %startsc1%>=1 && endlocal && set result=0 && goto :eof ! endlocal && set result=%startsec%+%startsc1% && set hiddsecL=%startsc1% && goto :eof
if %partitio%==%lognum% && if not %startsec%==0 &; if not %partid2%==0x1 if not %partid2%==0x11 if not %partid2%==0x4 if not %partid2%==0x14 if not %partid2%==0x6 if not %partid2%==0x16 if not %partid2%==0xB if not %partid2%==0x1B if not %partid2%==0xE if not %partid2%==0x1E if not %partid2%==0xC if not %partid2%==0x1C |; if not %startsc2%>=1 && endlocal && set result=0 && goto :eof ! endlocal && set result=%startsec%+%startsc2% && set hiddsecL=%startsc2% && goto :eof
if %partitio%==%lognum% && if not %startsec%==0 &; if not %partid3%==0x1 if not %partid3%==0x11 if not %partid3%==0x4 if not %partid3%==0x14 if not %partid3%==0x6 if not %partid3%==0x16 if not %partid3%==0xB if not %partid3%==0x1B if not %partid3%==0xE if not %partid3%==0x1E if not %partid3%==0xC if not %partid3%==0x1C |; if not %startsc3%>=1 && endlocal && set result=0 && goto :eof ! endlocal && set result=%startsec%+%startsc3% && set hiddsecL=%startsc3% && goto :eof
if not %partid0%==0x5 && if not %partid0%==0xF && if not %partid0%==0x15 && if not %partid0%==0x1F && if not %partid1%==0x5 && if not %partid1%==0xF && if not %partid1%==0x15 && if not %partid1%==0x1F && if not %partid2%==0x5 && if not %partid2%==0xF && if not %partid2%==0x15 && if not %partid2%==0x1F && if not %partid3%==0x5 && if not %partid3%==0xF && if not %partid3%==0x15 && if not %partid3%==0x1F && endlocal && set result=0 && goto :eof
set /a lognum=%lognum%+1
if %startsec%==0 &; if not %partid0%==0x5 if not %partid0%==0xF if not %partid0%==0x15 if not %partid0%==0x1F || set startext=%startsc0% ! if not %partid1%==0x5 if not %partid1%==0xF if not %partid1%==0x15 if not %partid1%==0x1F || set startext=%startsc1% ! if not %partid2%==0x5 if not %partid2%==0xF if not %partid2%==0x15 if not %partid2%==0x1F || set startext=%startsc2% ! if not %partid3%==0x5 if not %partid3%==0xF if not %partid3%==0x15 if not %partid3%==0x1F || set startext=%startsc3%
if %startsec%==0 &; if not %partid0%==0x5 if not %partid0%==0xF if not %partid0%==0x15 if not %partid0%==0x1F || set /a startsec=%startsc0% && goto :logicalpartitionloop ! if not %partid1%==0x5 if not %partid1%==0xF if not %partid1%==0x15 if not %partid1%==0x1F || set /a startsec=%startsc1% && goto :logicalpartitionloop ! if not %partid2%==0x5 if not %partid2%==0xF if not %partid2%==0x15 if not %partid2%==0x1F || set /a startsec=%startsc2% && goto :logicalpartitionloop ! if not %partid3%==0x5 if not %partid3%==0xF if not %partid3%==0x15 if not %partid3%==0x1F || set /a startsec=%startsc3% && goto :logicalpartitionloop
if not %startsec%==0 &; if not %partid0%==0x5 if not %partid0%==0xF if not %partid0%==0x15 if not %partid0%==0x1F || set /a startsec=%startext%+%startsc0% && goto :logicalpartitionloop ! if not %partid1%==0x5 if not %partid1%==0xF if not %partid1%==0x15 if not %partid1%==0x1F || set /a startsec=%startext%+%startsc1% && goto :logicalpartitionloop ! if not %partid2%==0x5 if not %partid2%==0xF if not %partid2%==0x15 if not %partid2%==0x1F || set /a startsec=%startext%+%startsc2% && goto :logicalpartitionloop ! if not %partid3%==0x5 if not %partid3%==0xF if not %partid3%==0x15 if not %partid3%==0x1F || set /a startsec=%startext%+%startsc3% && goto :logicalpartitionloop
endlocal && set result=0
goto :eof
::
:lsspaces
#-# Taken from FATCOPY.G4B, but more universal: now used for '=' too
setlocal && set *
#ORIGINAL#setlocal && set * && set mdmem=%mdmem% && set "file=%file%"
set mdmem=0x300
set "file=%~1"
set numspace= && set skip=0
echo -n > (md)%mdmem%+1
pause --wait=0 "%file%" > (md)%mdmem%+1
cat --locate=%~2 (md)%mdmem%+1 > nul ;; set /a numspace=%@retval% > nul
#ORIGINAL#cat --locate=\x20 (md)%mdmem%+1 > nul ;; set /a numspace=%@retval% > nul
if %numspace%==0 && endlocal && set "file=%file%" && goto :eof
:spaceloop
if %numspace%==0 && cat (md)%mdmem%+1 | set file= &; set "file=%file:~1,-1%" &; endlocal && set "file=%file%" && goto :eof
cat --skip=%skip% --locate=%~2 --number=1 (md)%mdmem%+1 > nul ;; set /A skip=%?% > nul
#ORIGINAL#cat --skip=%skip% --locate=\x20 --number=1 (md)%mdmem%+1 > nul ;; set /A skip=%?% > nul
set /A skipmin1=%skip%-1 > nul
cat --skip=%skipmin1% --locate=\x5C --number=1 (md)%mdmem%+1 > nul ;; set /A skipmin1=%?% > nul
if %skipmin1%>=1 && set /A skipmin1=%skipmin1%+1 > nul
if %skip%==%skipmin1% && set /a numspace=%numspace%-1 > nul && set /A skip=%skip%+2 > nul && goto :spaceloop
set /A seek=%skip%+1 > nul
raw dd if=(md)%mdmem%+1 of=(md)%mdmem%+1 bs=1 skip=%skip% seek=%seek%
cat --skip=%skip% --locate=%~2 --replace=\x5C --number=1 (md)%mdmem%+1 > nul
#ORIGINAL#cat --skip=%skip% --locate=\x20 --replace=\x5C --number=1 (md)%mdmem%+1 > nul
set /a numspace=%numspace%-1 > nul
if %numspace%==0 && cat (md)%mdmem%+1 | set file= &; set "file=%file:~1,-1%" &; endlocal && set "file=%file%" && goto :eof
set /A skip=%skip%+2 > nul
goto :spaceloop
::
:help
setlocal
pager status > nul ;; set pagersts=%@retval% > nul ;; pager on
echo FATINFO.G4B v0.8.1 (20260124), by deomsh (grub4dos version 20170607 or higher)
echo Function Get FAT-info (no switch), or switch: basic tests or return variable(s)
:smallhelp
echo -e Use 1    FATINFO.G4B [--mdbase=m] [--hex] DEVICE [switch]
echo -e Use 2    FATINFO.G4B [--mdbase=m] [--start=n|--skip=N|--partition=p] [--hex]
echo -e $[]                      FILE [switch]
echo -e Use 3    FATINFO.G4B [--mdbase=m] [--start=n|--skip=N|--partition=p] [--hex]
echo -e $[]                      BLOCKLIST [switch]
echo -e Use 4    FATINFO.G4B [--mdbase=m] [--start=n|--skip=N] [--hex] DISK [switch]
echo Help     FATINFO.G4B /?
echo -e Switch   /T|/TQ|/F|/FT|/A|/A32|/L|/L32|/B|/BC|/V && if %~1==smallhelp && goto :smallhelp2
echo Remarks  DEVICE: existing FAT-devices (always with parentheses!)
echo $[]         Ram-disk is treated as FILE (rd) or (rd,pt_num)
echo $[]          Partitioned ram-disk is NOT supported with grub4efi, use '--start=n'
echo $[]         FILE: existing FAT-imagefile (without extension, no '+' in name-part)
echo $[]          if contains Long File Name use escaped spaces/ =: '\ ' '\=' or "FILE"
echo $[]         BLOCKLIST: containing FAT volume/ partition is treated as FILE
echo $[]         DISK: containing FAT volume/ partition on given offset (no default!)
echo $[]         --mdbase=sector to change startsecor of memory in use (default 0x3000)
echo $[]                  max 512 sectors needed
echo $[]         --start=sector to set sector-offset of bootsector in image/ iso/ disk
echo $[]         --skip=address to set byte-offset of bootsector in image/ iso/ disk
echo $[]         --partition=0-62 to find bootsector in image/ iso/ blocklist
echo $[]                  on MBR-based partitions only (>=4 is logical partition)
echo $[]         To get FAT info, size must be a least Hidden + Reserved + FAT sectors
echo $[]         --hex to view in hex bootsectors and first sector of FAT(s)
echo $[]         Detected (standard) bootcodes: MS-DOS 3.3/4.0/5.0/7.1, Windows 2k/XP/ && echo $[]            Vista/10, FREEDOS, REACTOS, GRUB (fat); MS-DOS 7.1, Windows 2k/XP/ && echo $[]              Vista/10, FREEDOS, REACTOS, GRUB (fat32)
echo $[]            If not detected (standard) boot files tried: IBMBIO.COM, IO.SYS,
echo $[]              NTLDR, BOOTMGR, KERNEL.SYS, FREELDR.SYS and GRLDR
echo
echo -e Switch   Only ONE switch allowed:
echo -e $[]         /T tests: Media descriptor, Fit on partition, Last sector valid\n          Number of tracks/cylinders, Balanced CHS/LBA, Signatures\n          Sectors per FAT Media descriptor in FAT1\n          Check Dirty bit, FAT1/FAT2 equal, Bad clusters (FAT), Padding sectors\n          FSInfo equal to free cluster-count (fat32 only)\n          FSLastFree equal to last free cluster (fat32 only)
echo -e $[]         /TQ quit tests: if all tests passed variable result=1\n          otherwise 0 (if no/ not all tests done variable result not exist)
echo $[]         /F quiet test if DEVICE is FAT (variable result=1/0)
echo -e $[]         /FT quiet test if DEVICE is FATxx\n          (variable result=fat32/fat16/fat12 or no result)
echo $[]         /A get quiet free space on device (variable result=n bytes)
echo $[]         /A32 quiet full count of free space on fat32 (variable result=n bytes)
echo -e $[]         /L quiet last allocated cluster on device\n          (variable result=clusternumber)
echo $[]         /L32 same, but full count on fat32 (variable result=clusternumber)
echo -e $[]         /B quiet number of clusters marked as bad\n          (variable result=number of bad clusters)
echo -e $[]         /BC quiet fat/ fat32 bootcode\n          (variable result=Bootcode/Empty/Unknown)
echo -e $[]         /V get quiet fat info on device. variables: FILESYS BYTEPSEC SECPCLUS\n          RESERVED NUMFATS SECPFAT SECTRACK NUMHEADS ROOTENTR DEVSECT MEDIABYT\n          UUID BOOTCODE + on fat32: CLUSFREE NEXTFREE (FSInfo)
echo
echo Example  FATINFO.G4B (fd0)
echo Example  FATINFO.G4B (hd0,0)
echo Example  FATINFO.G4B (rd)
echo Example  FATINFO.G4B (rd,0)
echo Example  FATINFO.G4B --start=63 (rd)
echo Example  FATINFO.G4B (fd0) /T
echo Example  FATINFO.G4B (hd0,0) /T
echo -e Example  FATINFO.G4B (rd) /TQ \x3B\x3B set result
echo -e Example  FATINFO.G4B (rd) /F \x3B\x3B set result
echo -e Example  FATINFO.G4B (hd2,0) /FT \x3B\x3B set result
echo -e Example  FATINFO.G4B (hd1,0) /V \x3B\x3B set
echo -e Example  FATINFO.G4B (hd1,0) /L \x3B\x3B set result
echo -e Example  FATINFO.G4B (hd0,0) /A32 \x3B\x3B set result
echo -e Example  FATINFO.G4B (hd0,0) /BC \x3B\x3B set result
#ORG#echo -e Example  FATINFO.G4B (hd0,0) /B \x3B\x3B set result
echo -e Example  FATINFO.G4B (hd0,0)/FDDIMAGE.IMG
echo -e Example  FATINFO.G4B --start=63 /HDDIMAGE.IMG
echo -e Example  FATINFO.G4B --skip=0x7E00 (hd0,0)/ELTORITO.ISO
#ORG#echo -e Example  FATINFO.G4B --skip=0x85E00 /HDDIMAGE.IMG
echo -e Example  FATINFO.G4B --partition=0 (hd0,0)44992028+0x400000
echo -e Example  FATINFO.G4B --start=63 (hd0,0)44992028+0x400000
echo -e Example  FATINFO.G4B (0xe0)0x15+720
echo -e Example  FATINFO.G4B --start=1929 (0x9f)
echo Example  FATINFO.G4B (hd0,0)/Long\ Image\ Name\ \=\ Floppy.IMG
echo -e Example  FATINFO.G4B --partition=0 "(hd0,0)/L F N = Harddisk.IMG" /T
echo
if %pagersts%==0 && pager off
endlocal
goto :eof
:smallhelp2
echo Example  FATINFO.G4B (hd0,0)
echo Example  FATINFO.G4B (rd)
echo Example  FATINFO.G4B (fd0) /T
echo -e Example  FATINFO.G4B (hd1,0)/FDDIMAGE.IMG
echo -e Example  FATINFO.G4B --start=63 /HDDIMAGE.IMG
echo -e Example  FATINFO.G4B --skip=0x7E00 (hd0,0)/ELTORITO.ISO
echo -e Example  FATINFO.G4B --partition=0 "(hd0,0)/L F N = Harddisk.IMG" /T
echo -e Example  FATINFO.G4B (0xe0)0x15+720
#ORG#echo -e Example  FATINFO.G4B --start=1929 (0x9f)
goto :eof
#ToUseForDebugging#
#OKE_XX_vars##echo -n > (md)0x302+60 && set > (md)0x302+60 && raw cat --locate=\x0A (md)0x302+60 > nul &; echo %0 NUMVARS=%@retval% && cat --locate=\x0A --replace=\x20 (md)0x302+60 && raw cat (md)0x302+60 && echo && echo -n && pause Press a Key to Continue... && echo
